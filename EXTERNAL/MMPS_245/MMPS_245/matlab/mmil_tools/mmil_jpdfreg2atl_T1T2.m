function M_T1_to_T2 = mmil_jpdfreg2atl_T1T2(fname_T1,fname_T2,varargin)
% function M_T1_to_T2 = mmil_jpdfreg2atl_T1T2(fname_T1,fname_T2,[options])
%
% Purpose: perform rigid body registration between
%   T2-weighted and T1-weighted MRI volumes (uses Dominic Holland's reg)
%   Registers T1 and T2 MRI volumes in atlas space
% 
% Usage: mmil_jpdfreg2atl_T2T1(fname_T2,fname_T1,'key1',val1,...)
%
% Required Input:
%   fname_T1: full path file name of T1-weighted volume (mgh/mgz format)
%   fname_T2: full path file name of T2-weighted volume (mgh/mgz format)
%
% Optional Input:
%   'outdir': output path for files generated by reg
%     {default = pwd}
%   'fname_T1_mask': full path of brain mask for T1-weighted volume
%     If not supplied, will create the T1 mask using mmil_dct_brainmask
%     {default = []}
%   'paramfile': full or relative path of parameter file
%     If relative, relative to $MMPS_PARMS/REG
%     {default = []}
%   'binfile': full or relative path of reg binary file
%     {default = 'reg'}
%   'logfile': file name of output log file
%     If relative, relative to outdir
%     {default = 'reg.log'}
%   'atlasdir': full path of atlas directory
%     {default =  [getenv('MMPS_DIR') '/atlases']}}
%   'atlasname': name of atlas file (omit .mat extension)
%     full path or relative to atlasdir
%     {default =  'T1_Atlas/T1_atlas'}
%   'cleanup_flag': [0|1] removes files created by mmil_reg to correct 
%     for residual translation {default =1}
%   'forceflag': [0|1] overwrite existing output files
%     {default = 0}
% 
% Created:  01/24/12 by Vijay Venkatraman (Original from Don Hagler)
% Prev Mod: 04/26/17 by Don Hagler
% Last Mod: 05/11/17 by Don Hagler
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% parse input parameters

M_T1_to_T2 = [];
if ~mmil_check_nargs(nargin,2), return; end;
parms = mmil_args2parms(varargin, { ...
  'fname_T1',fname_T1,[],...
  'fname_T2',fname_T2,[],...
  'outdir',pwd,[],...
  'fname_T1_mask',[],[],...
  'paramfile',[],[],...
  'binfile','reg',[],...
  'logfile','reg.log',[],...
  'forceflag',false,[false true],...
...
  'atlasdir',[],[],...
  'atlasname','T1_Atlas/T1_atlas',[],...
  'bindir',[],[],...
  'parmsdir',[],[],...
  'sincflag',true,[false true],...
  'interpm',2,[1:5],...
  'cleanup_flag',true,[false true],...
...
  'smoothmask_flag',true,[false,true],...
  'thresh0',0.01,[0,1000],...
  'smooth1',10,[0,100],...
  'thresh1',0.5,[0,1],...
  'smooth2',5,[0,100],...
  'thresh2',0.5,[0,1],...
  'smooth3',5,[0,100],...
  'thresh3',0.3,[0,1],...
});

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% check parms

% check parameter file
if ~isempty(parms.paramfile)
  if isempty(parms.parmsdir)
    parms.parmsdir = [getenv('MMPS_PARMS') '/REG'];
  end;
  if isempty(regexp(parms.paramfile,'^/')) % relative path
    parms.paramfile = [parms.parmsdir '/' parms.paramfile];
  end;
  if ~exist(parms.paramfile,'file')
    error('parameter file %s not found',parms.paramfile);
  end;
end;

% check binary
if isempty(parms.bindir)
  parms.bindir = [getenv('MMPS_DIR') '/bin'];
end;
if isempty(regexp(parms.binfile,'^/')) % relative path
  parms.binfile = [parms.bindir '/' parms.binfile];
end;
if ~exist(parms.binfile,'file')
  error('binary file %s not found',parms.binfile);
end;

% check atlas files
if isempty(parms.atlasdir)
  parms.atlasdir = [getenv('MMPS_DIR') '/atlases'];
end;

if ~exist(parms.atlasdir,'dir')
  error('atlas directory %s not found',parms.atlasdir);
end;

% set the directory for T1/T2 atlas
parms.T1T2atlasdir = [parms.atlasdir '/T1T2'];
if ~exist(parms.T1T2atlasdir,'dir')
  error('T1/T2 atlas directory %s not found',parms.T1T2atlasdir);
end;

parms.fname_atlasT2 = [parms.T1T2atlasdir '/atlasT2.mgz'];
parms.fname_atlasT2_mask = [parms.T1T2atlasdir '/maskT2.mgz'];
if ~exist(parms.fname_atlasT2,'file')
  error('atlas T2 file %s not found',parms.fname_atlasT2);
end;
if ~exist(parms.fname_atlasT2_mask,'file')
  error('mask T2 file %s not found',parms.fname_atlasT2_mask);
end;
parms.fname_atlasT1 = [parms.T1T2atlasdir '/atlasT1.mgz'];
parms.fname_atlasT1_mask = [parms.T1T2atlasdir '/maskT1.mgz'];
if ~exist(parms.fname_atlasT1,'file')
  error('atlas T1 file %s not found',parms.fname_atlasT1);
end;
if ~exist(parms.fname_atlasT1_mask,'file')
  error('mask T1 file %s not found',parms.fname_atlasT1_mask);
end;

% check input files
if ~exist(parms.fname_T1,'file')
  error('file %s not found',parms.fname_T1);
end;
if ~exist(parms.fname_T2,'file')
  error('file %s not found',parms.fname_T2);
end;

% create output dir if needed
mmil_mkdir(parms.outdir);

% check input mask file
if isempty(parms.fname_T1_mask) | ~exist(parms.fname_T1_mask,'file')
  [vol_in,mr_parms] = ctx_load_mgh(parms.fname_T1);
  parms.fname_T1_mask = [parms.outdir '/T1mask.mgz'];
  [vol_out,M_Atl_to_Subj] = mmil_dct_brainmask(vol_in,'fname_mask',parms.fname_T1_mask,...
    'atlasname',parms.atlasname,'atlasdir',parms.atlasdir,'forceflag',parms.forceflag);
  clear vol_in M_Atl_to_Subj;   
  voltmp = vol_out; 
  voltmp.imgs(:) = 0;
  voltmp.imgs = 1.0*(vol_out.imgs>0.5);  
  ctx_save_mgh(voltmp,parms.fname_T1_mask);  
  clear voltmp vol_out;
end;

% fname_T1_mask is a binary mask, smoothing is done here for mmil_reg
if parms.smoothmask_flag
  [vol_in, mr_parms] =  ctx_load_mgh(parms.fname_T1_mask);
  [T1pathstr,T1stem,T1ext] = fileparts(parms.fname_T1_mask);
  parms.fname_T1_mask = sprintf('%s/%s_sm%s',parms.outdir,T1stem,T1ext);
  vol_out = mmil_dilate_mask(vol_in,'thresh0',parms.thresh0,'smooth1',parms.smooth1,...
    'thresh1',parms.thresh1,'smooth2',parms.smooth2,'thresh2',parms.thresh2,...
    'smooth3',parms.smooth3,'thresh3',parms.thresh3);
  ctx_save_mgh(vol_out, parms.fname_T1_mask); 
  clear vol_in vol_out;
end;

% get info about input files
[M_T1,volsz_T1] = fs_read_header(parms.fname_T1);
[M_T2,volsz_T2] = fs_read_header(parms.fname_T2);
[tmp,tstem_T1,text_T1] = fileparts(parms.fname_T1);
[tmp,tstem_T2,text_T2] = fileparts(parms.fname_T2);

% set full log file name
if isempty(regexp(parms.logfile,'^/'))
  parms.logfile = [parms.outdir '/' parms.logfile];
end;
if exist(parms.logfile,'file')
  tmpstr = '\n####################################################\n';
else
  tmpstr = [];
end;
mmil_logstr(parms,'%sstart registration %s\n',tmpstr,datestr(now));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% register T1 to atlas

fname_T1atl_regmat = [parms.outdir '/M_T1atl_to_T1.mat'];
fname_T1atl_regtxt = [parms.outdir '/M_T1atl_to_T1.txt'];
fname_T1_atl = [parms.outdir '/' tstem_T1 '_atl.mgz'];
tags = {'interpm','outdir','logfile','binfile','paramfile'};
args = mmil_parms2args(parms,tags);
M_T1atl_to_T1 = mmil_reg(parms.fname_atlasT1,parms.fname_T1,args{:},...
  'fname_maskA',parms.fname_atlasT1_mask,...
  'fname_maskB',parms.fname_T1_mask,...
  'fname_regmat',fname_T1atl_regmat,...
  'fname_regtxt',fname_T1atl_regtxt,...
  'fname_regout',fname_T1_atl);
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% register T2 to atlas

fname_T2atl_regmat = [parms.outdir '/M_T2atl_to_T2.mat'];
fname_T2atl_regtxt = [parms.outdir '/M_T2atl_to_T2.txt'];
fname_T2_atl = [parms.outdir '/' tstem_T2 '_atl.mgz'];
tags = {'interpm','outdir','logfile','binfile','paramfile'};
args = mmil_parms2args(parms,tags);
M_T2atl_to_T2 = mmil_reg(parms.fname_atlasT2,parms.fname_T2,args{:},...
  'fname_maskA',parms.fname_atlasT2_mask,...
  'fname_regmat',fname_T2atl_regmat,...
  'fname_regtxt',fname_T2atl_regtxt,...
  'fname_regout',fname_T2_atl);
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% resample mask to atlas space
if isempty(parms.fname_T1_mask)
  error('file %s not found',parms.fname_T1_mask);
else 
  [tmp,tstem_maskT1,text_maskT1] = fileparts(parms.fname_T1_mask);
  fname_T1_mask_atl = sprintf('%s/%s_atl%s',...
    parms.outdir,tstem_maskT1,text_maskT1);
  if ~exist(fname_T1_mask_atl,'file') || parms.forceflag
    fprintf('%s: resampling mask to atlas...\n',mfilename);
    vol_T1_atl = ctx_load_mgh(fname_T1_atl);
    vol_mask = ctx_load_mgh(parms.fname_T1_mask);
    vol_mask_atl = vol_resample_pad(vol_mask,vol_T1_atl,M_T1atl_to_T1,1);
    ctx_save_mgh(vol_mask_atl,fname_T1_mask_atl);
  end;
end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% register T2 to T1 with jpdf: Iteration 1

fname_T2T1itr1_regmat = [parms.outdir '/M_T1atl_to_T2atl_itr1.mat'];
fname_T2T1itr1_regtxt = [parms.outdir '/M_T1atl_to_T2atl_itr1.txt'];
fname_T2_T1_itr1 = [parms.outdir '/' tstem_T2 '_T1_itr1.mgz'];
parms.options = '-jpr -jpbrrMultScale';
tags = {'sincflag','interpm','logfile','binfile','paramfile','options','cleanup_flag'};
args = mmil_parms2args(parms,tags);
M_T1atl_to_T2atl_itr1 = mmil_reg(fname_T1_atl,fname_T2_atl,args{:},...
  'rigid_flag',1,...
  'fname_maskA',fname_T1_mask_atl,...
  'fname_regmat',fname_T2T1itr1_regmat,...
  'fname_regtxt',fname_T2T1itr1_regtxt,...
  'fname_regout',fname_T2_T1_itr1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% register the T2 to T2 output of jpdf iteration 1

fname_T2T2_regmat = [parms.outdir '/M_T2itr1_to_T2.mat'];
fname_T2T2_regtxt = [parms.outdir '/M_T2itr1_to_T2.txt'];
fname_T2_T2 = [parms.outdir '/' tstem_T2 '_T2.mgz'];
parms.options= '-rrf';
tags = {'sincflag','interpm','logfile','binfile','paramfile','options','cleanup_flag'};
args= mmil_parms2args(parms,tags); 
M_T2itr1_to_T2 = mmil_reg(fname_T2_T1_itr1,parms.fname_T2,args{:},...
  'rigid_flag',1,...
  'fname_maskA', parms.fname_T1_mask,...
  'fname_regmat',fname_T2T2_regmat,...
  'fname_regtxt',fname_T2T2_regtxt,...
  'fname_regout',fname_T2_T2);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% register T2 to T1 with jpdf: Iteration 2

fname_T2T1itr2_regmat = [parms.outdir '/M_T1_to_T2_itr2.mat'];
fname_T2T1itr2_regtxt = [parms.outdir '/M_T1_to_T2_itr2.txt'];
fname_T2_T1_itr2 = [parms.outdir '/' tstem_T2 '_T1_itr2.mgz'];
parms.options = '-jpr -jpbrrMultScale';
tags = {'sincflag','interpm','logfile','binfile','paramfile','options','cleanup_flag'};
args = mmil_parms2args(parms,tags);
M_T1_to_T2_itr2 = mmil_reg(parms.fname_T1,fname_T2_T2,args{:},...
  'rigid_flag',1,...
  'fname_maskA', parms.fname_T1_mask,...
  'fname_regmat',fname_T2T1itr2_regmat,...
  'fname_regtxt',fname_T2T1itr2_regtxt,...
  'fname_regout',fname_T2_T1_itr2);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% calculate transformation between original volumes
M_T1_to_T2 = M_T2itr1_to_T2 * M_T1_to_T2_itr2;
