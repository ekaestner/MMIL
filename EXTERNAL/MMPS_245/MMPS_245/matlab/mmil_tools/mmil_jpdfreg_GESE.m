function M_GE_to_SE = mmil_jpdfreg_GESE(fname_GE,fname_SE,varargin)
% function M_GE_to_SE = mmil_jpdfreg_GESE(fname_GE,fname_SE,[options])
%
% Purpose: perform rigid body registration between
%   spin-echo (T2-weighted field map) and gradient-echo (T2*-weighted fMRI) volumes
%   uses Dominic Holland's reg
%
% Usage: mmil_jpdfreg_GESE(fname_GE,fname_SE,'key1',val1,...)
%
% Required Input:
%   fname_GE: full path file name of gradient echo (GE) volume (mgh/mgz format)
%   fname_SE: full path file name of spin echo (GE) volume (mgh/mgz format)
%
% Optional Input:
%   'fname_GE_mask': full path of brain mask for gradient echo (GE) volume
%     If not supplied, will create one using epi_brainmask
%     {default = []}
%   'fname_SE_mask': full path of brain mask for spin echo (GE) volume
%     If not supplied, will create one using epi_brainmask
%     {default = []}
%   'mask_thresh': cumulative probability of log intensity (max is 1)
%     {default = 0.82}
%   'outdir': output path for files generated by reg
%     {default = pwd}
%   'regmask': [0|1] use correlation of masks for initial registration
%     {default = 1}
%   'niters': number of iterations
%     {default = 2}
%   'paramfile': full or relative path of parameter file
%     If relative, relative to $MMPS_PARMS/REG
%     {default = []}
%   'binfile': full or relative path of reg binary file
%     {default = 'reg'}
%   'logfile': file name of output log file
%     If relative, relative to outdir
%     {default = 'reg.log'}
%   'cleanup_flag': [0|1] removes files created by mmil_reg to correct 
%     for residual translation
%     {default = 1}
%   'verbose': [0|1] display status updates
%     {default = 1}
%   'forceflag': [0|1] overwrite existing output files
%     {default = 0}
% 
% Created:  06/10/17 by Don Hagler
% Last Mod: 07/20/17 by Don Hagler
%

% Based on mmil_jpdfreg2subj_T1T2
% Created:  01/24/12 by Vijay Venkatraman
% Last Mod: 05/11/17 by Don Hagler

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% parse input parameters

M_GE_to_SE = [];
if ~mmil_check_nargs(nargin,2), return; end;

% check input parameters
parms = check_input(fname_GE,fname_SE,varargin);

% prepare data for registration
parms = prep_data(parms);

% register SE to GE
M_GE_to_SE = register_data(parms);

% apply transform to SE
fname_SE_resGE = apply_transform(parms,M_GE_to_SE);

return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function parms = check_input(fname_GE,fname_SE,options)
  parms = mmil_args2parms(options,{...
    'fname_GE',fname_GE,[],...
    'fname_SE',fname_SE,[],...
  ...
    'fname_GE_mask',[],[],...
    'fname_SE_mask',[],[],...
    'mask_thresh',0.82,[0,1],...
    'outdir',pwd,[],...
    'regmask_flag',true,[false true],...
    'niters',2,[1,2,3],...
    'paramfile',[],[],...
    'binfile','reg',[],...
    'logfile','reg.log',[],...
    'verbose',true,[false true],...
    'forceflag',false,[false true],...
  ...
    'bindir',[],[],...
    'parmsdir',[],[],...
    'rigid_flag',true,[false true],...
    'sincflag',true,[false true],...
    'interpm',2,[1:5],...
    'cleanup_flag',true,[false true],...
  ...
    'reg_tags',{'rigid_flag','sincflag','interpm','logfile','binfile','paramfile',...
                'options','cleanup_flag'},[],...
    'jpdf_options','-jpr -jpbrrMultScale',[],...
    'corr_options',[],[],...
  });

  % check parameter file
  if ~isempty(parms.paramfile)
    if isempty(parms.parmsdir)
      parms.parmsdir = [getenv('MMPS_PARMS') '/REG'];
    end;
    if isempty(regexp(parms.paramfile,'^/')) % relative path
      parms.paramfile = [parms.parmsdir '/' parms.paramfile];
    end;
    if ~exist(parms.paramfile,'file')
      error('parameter file %s not found',parms.paramfile);
    end;
  end;

  % check binary
  if isempty(parms.bindir)
    parms.bindir = [getenv('MMPS_DIR') '/bin'];
  end;
  if isempty(regexp(parms.binfile,'^/')) % relative path
    parms.binfile = [parms.bindir '/' parms.binfile];
  end;
  if ~exist(parms.binfile,'file')
    error('binary file %s not found',parms.binfile);
  end;

  % check input files
  if ~exist(parms.fname_GE,'file')
    error('file %s not found',parms.fname_GE);
  end;
  if ~exist(parms.fname_SE,'file')
    error('file %s not found',parms.fname_SE);
  end;

  % set full log file name
  if isempty(regexp(parms.logfile,'^/'))
    parms.logfile = [parms.outdir '/' parms.logfile];
  end;
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function parms = prep_data(parms)
  mmil_mkdir(parms.outdir);
  if parms.verbose
    fprintf('%s: preparing data...\n',mfilename);
  end;
  mmil_logstr(parms,'prepare data: %s\n',datestr(now));

  % get info about input files
  [parms.M_GE,parms.volsz_GE] = mmil_load_mgh_info(parms.fname_GE,parms.forceflag,parms.outdir);
  [parms.M_SE,parms.volsz_SE] = mmil_load_mgh_info(parms.fname_SE,parms.forceflag,parms.outdir);
  [tmp,parms.tstem_GE,text_GE] = fileparts(parms.fname_GE);
  [tmp,parms.tstem_SE,text_SE] = fileparts(parms.fname_SE);

  % if GE nframes>1, extract single frame
  if parms.volsz_GE(4)>1
    fname_GE = sprintf('%s/%s_f0.mgz',parms.outdir,parms.tstem_GE);
    if ~exist(fname_GE,'file') || parms.forceflag
      [vol,M] = fs_load_mgh(parms.fname_GE,[],1,0,1);
      fs_save_mgh(vol,fname_GE,M);
    end;
    parms.fname_GE = fname_GE;
  end;

  % if SE nframes>1, extract single frame
  fname_SE = sprintf('%s/%s_f0.mgz',parms.outdir,parms.tstem_SE);
  if parms.volsz_SE(4)>1
    if ~exist(fname_SE,'file') || parms.forceflag
      [vol,M] = fs_load_mgh(parms.fname_SE,[],1,0,1);
      fs_save_mgh(vol,fname_SE,M);
    end;
  else
    fs_copy_mgh(parms.fname_SE,fname_SE);
  end;
  parms.fname_SE = fname_SE;

  % set input mask file
  if isempty(parms.fname_GE_mask)
    parms.fname_GE_mask = sprintf('%s/%s_mask.mgz',parms.outdir,parms.tstem_GE);
  end;
  % create brain mask from GE
  if ~exist(parms.fname_GE_mask,'file') || parms.forceflag
    epi_brainmask(parms.fname_GE,parms.fname_GE_mask,...
      'thresh',parms.mask_thresh,...
      'forceflag',parms.forceflag);
  end;
  
  % set input mask file
  if isempty(parms.fname_SE_mask)
    parms.fname_SE_mask = sprintf('%s/%s_mask.mgz',parms.outdir,parms.tstem_SE);
  end;
  % create brain mask from SE
  if ~exist(parms.fname_SE_mask,'file') || parms.forceflag
    epi_brainmask(parms.fname_SE,parms.fname_SE_mask,...
      'thresh',parms.mask_thresh,...
      'forceflag',parms.forceflag);
  end;
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function M_GE_to_SE = register_data(parms)
  fname_SE = parms.fname_SE;
  if parms.regmask_flag
    M_GE_to_SE = reg_GESE(parms,parms.fname_GE_mask,parms.fname_SE_mask,'_mask',0);
  else
    M_GE_to_SE = eye(4);
  end;
  for i=1:parms.niters
    if parms.regmask_flag || i>1
      outfix = sprintf('_itr%d',i-1);
      fname_SE = apply_transform(parms,M_GE_to_SE,outfix);
    end;
    outfix = sprintf('_itr%d',i);
    M_GE_to_SE_itr = reg_GESE(parms,parms.fname_GE,fname_SE,outfix,1);
    M_GE_to_SE = M_GE_to_SE * M_GE_to_SE_itr;
  end;
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function M_GE_to_SE = reg_GESE(parms,fname_GE,fname_SE,outfix,jpdf_flag)
  if ~exist('outfix','var'), outfix = []; end;
  if ~exist('jpdf_flag','var') || isempty(jpdf_flag), jpdf_flag = 1; end;
  M_GE_to_SE = [];
  if parms.verbose
    if isempty(outfix)
      fprintf('%s: registering data...\n',mfilename);
    else
      fprintf('%s: registering data (%s)...\n',mfilename,regexprep(outfix,'_',''));
    end;
  end;
  mmil_logstr(parms,'register data %s: %s\n',datestr(now),outfix);
  % register SE to GE with jpdf (actually mutual information)
  outdir = sprintf('%s/reg%s',parms.outdir,outfix);
  fname_GESE_regmat = sprintf('%s/M_GE_to_SE%s.mat',outdir,outfix);
  fname_GESE_regtxt = sprintf('%s/M_GE_to_SE%s.txt',outdir,outfix);
  fname_SE_resGE_LIA = sprintf('%s/%s_resGE_LIA%s.mgz',outdir,parms.tstem_SE,outfix);
  if jpdf_flag
    parms.options = parms.jpdf_options;
  else
    parms.options = parms.corr_options;
  end;
  args = mmil_parms2args(parms,parms.reg_tags);
  M_GE_to_SE = mmil_reg(fname_GE,fname_SE,args{:},...
    'outdir',outdir,...
    'fname_maskA',parms.fname_GE_mask,...
    'fname_regmat',fname_GESE_regmat ,...
    'fname_regtxt',fname_GESE_regtxt,...
    'fname_regout',fname_SE_resGE_LIA);
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function fname_SE_resGE = apply_transform(parms,M_GE_to_SE,outfix)
  if ~exist('outfix','var'), outfix = []; end;
  if parms.verbose
    if isempty(outfix)
      fprintf('%s: applying transform...\n',mfilename);
    else
      fprintf('%s: applying transform (%s)...\n',mfilename,regexprep(outfix,'_',''));
    end;
  end;
  mmil_logstr(parms,'apply transform %s: %s\n',datestr(now),outfix);
  % apply transform to SE into GE space
  if isempty(outfix)
    outdir = parms.outdir;
  else
    outdir = sprintf('%s/reg%s',parms.outdir,outfix);
    mmil_mkdir(outdir);
  end;
  fname_SE_resGE = sprintf('%s/%s_resGE%s.mgz',outdir,parms.tstem_SE,outfix);
  if ~exist(fname_SE_resGE,'file') || parms.forceflag
    [vol_SE,M_SE] = fs_load_mgh(parms.fname_SE);
    [vol_SE_resGE,M_SE_resGE] = mmil_resample_vol(vol_SE,M_SE,...
      'M_ref',parms.M_GE,'nvox_ref',parms.volsz_GE(1:3),...
      'M_reg',M_GE_to_SE);
    fs_save_mgh(vol_SE_resGE,fname_SE_resGE,M_SE_resGE);
  end;
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
