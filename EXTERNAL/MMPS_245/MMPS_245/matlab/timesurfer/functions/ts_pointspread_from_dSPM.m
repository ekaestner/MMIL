function [spread,source,surfs] = ts_pointspread_from_dSPM(vertices,prefix,rootdir)
%function [spread,source,surfs] = ts_pointspread_from_dSPM(vertices,[prefix],[rootdir])
%
% Required Input:
%   vertices: cell array containing two vectors of vertex numbers,
%     one for each cortical hemisphere
%     Vertex numbers should correspond to full (non-decimated) freesurfer surface
%     Vertex numbers should be 0-based (like FreeSurfer's tksurfer)
%     If vertices supplied are not those included in the decimated dipoles
%       closest decdips will be used instead
%     e.g. {[100],[]} --> only vertex 100 in left hemisphere
%          {[100],[1,2,3]} --> vertex 100 in left hemisphere,
%                              vertices 1, 2, and 3 in right hemisphere
%          {'all','all'} --> all dec vertices in left and right hemispheres
%
% Optional Inupt:
%   prefix: prefix of ts_dSPM output files
%     Assuming a successful run of ts_dSPM, this prefix 
%       should enable access to all necessary parameters
%       (e.g. subject ID, file locations, etc.)
%     {default: 'dSPM'}
%   rootdir: directory containing matfiles dir with matfiles generated by
%     ts_dSPM with prefix
%     {default: current directory}
%
% Output:
%   spread: point spread for given vertices
%     Cell array containing two vectors, one for each hemisphere
%     Each vector will contain one value for each vertex of full (non-decimated) surface
%     returned as sqrt(F) (simulated dSPM calculations)
%   source: assumed source amplitudes for given vertices
%     Cell array containing two vectors, one for each hemisphere
%   surfs: struct array of surfaces (left and right)
%
% Created:  08/01/07 by Don Hagler
% Last Mod:  01/08/10 by Don Hagler
%

spread = [];
source = [];
surfs = [];

if (~mmil_check_nargs(nargin,1)) return; end;
if ~exist('prefix','var') | isempty(prefix), prefix = 'dSPM'; end;
if ~exist('rootdir','var') | isempty(rootdir), rootdir = pwd; end;

hemilist = {'lh','rh'};
surfname = 'inflated'; % so vertices don't jump sulci when looking for closest
ntrials = 100;

matfile=sprintf('%s/matfiles/%s_parms.mat',rootdir,prefix);
if ~exist(matfile,'file')
  error('file %s not found',matfile);
end;
load(matfile);

matfile=sprintf('%s/matfiles/%s_inverse.mat',rootdir,prefix);
if ~exist(matfile,'file')
  error('file %s not found',matfile);
end;
load(matfile);

G_norm = ts_gain_xyz2norm(G_xyz,...
  parms.lh_dip_info,parms.rh_dip_info,...
  parms.lh_dec_dips,parms.rh_dec_dips,...
  parms.trans);

S0 = zeros(length(find(parms.lh_dec_dips))+length(find(parms.rh_dec_dips)),1);

if size(G_norm,2) ~= size(S0,1)
  error('inconsistent number of sources in parameters (%d) and gain matrix (%d)',...
    size(S0,1),size(G_norm,2));
end;

for h=1:length(hemilist)
  hemi = hemilist{h};
  fname = sprintf('%s/surf/%s.%s',parms.subjdir,hemi,surfname);
  if ~exist(fname,'file')
    error('file %s not found',fname);
  end;
  surf = fs_read_surf(fname);
  if isempty(surf)
    error('failed to load freesurfer surface %s',fname);
  end;
  switch hemi
    case 'lh'
      nverts = length(parms.lh_dip_info);
      decdips = find(parms.lh_dec_dips);
      decind_offset = 0;
    case 'rh'
      nverts = length(parms.rh_dip_info);
      decdips = find(parms.rh_dec_dips);
      decind_offset = length(find(parms.lh_dec_dips));
  end;
  decind = decind_offset + [1:length(decdips)];
  if nverts ~= surf.nverts
    error('nverts in dSPM parms (%d) does not match that in surface file %s (%d)',...
      fname,nverts,surf.nverts);
  end;
  surfs(h).decdips = decdips;
  surfs(h).decind = decind;
  surfs(h).decind_offset = decind_offset;
  surfs(h).nverts = surf.nverts;
  surfs(h).nfaces = surf.nfaces;
  surfs(h).vertices = surf.vertices;
  surfs(h).faces = surf.faces;
end;

for h=1:length(hemilist)
  hemi = hemilist{h};
  % find closest decdips to input vertices
  vertex_list = vertices{h};
  if ischar(vertex_list)
    if strcmp(vertex_list,'all')
      surfs(h).input_vertices = surfs(h).decdips;
      surfs(h).closest_decind = surfs(h).decind_offset + ...
                                [1:length(surfs(h).decind)];
      surfs(h).closest_vertices = surfs(h).decdips;
      S0(surfs(h).closest_decind) = 1;
    else
      error('bad vertex_list: %s',vertex_list);
    end;
  else
    surfs(h).input_vertices = vertex_list;
    if ~isempty(vertex_list)
      vertex_list = reshape(vertex_list,[prod(size(vertex_list)),1]) + 1;
      if max(vertex_list) > nverts
        error('one or more vertex numbers in vertices (%d) exceeds number of surface vertices (%d)',...
          max(vertex_list),nverts);
      end;    
      num_input_vertices = length(vertex_list);
      closest_vertices = zeros(num_input_vertices,1);
      closest_decind = zeros(num_input_vertices,1);
      for i=1:num_input_vertices
        vertex = vertex_list(i);
        tmp_diff = surfs(h).vertices(surfs(h).decdips,:) -...
                   ones(length(surfs(h).decdips),1)*surfs(h).vertices(vertex,:);
        tmp_dist = sqrt(sum(tmp_diff.^2,2));
        [min_dist,vclose] = min(tmp_dist);
        surfs(h).closest_decind(i) = surfs(h).decind_offset + vclose;
        surfs(h).closest_vertices(i) = surfs(h).decdips(vclose);
      end;
      S0(surfs(h).closest_decind) = 1;
    else
      surfs(h).closest_decind = [];
      surfs(h).closest_vertices = [];
    end;
  end;
end;

% apply inverse to 'data'
Y = G_norm*S0; % synthesized data
S_xyz = (M*Y)'; % calculated sources

% calculate amplitudes and do noise normalization
% L should be number of trials in average, unless noise covariance
%   calculated from avg data, in which case it should be 1
num_sources = size(S_xyz,2)/3;
if parms.identity_ncov_flag | ...
   parms.calc_avg_ncov_flag | isempty(parms.noisecovar)
  L = 1;
else
  L = ntrials;
end;
nnfL2 = (nnf.^2)/L;
S = zeros(num_sources,1);
for s=1:num_sources
  j = 3*(s-1) + 1;
  k = j + 2;
  tmp = S_xyz(:,j:k);
  S(s) = sqrt(sum(tmp.^2,2));
  if parms.noisenorm_flag
    % noise normalization
    S(s) = (S(s).^2)/sum(nnfL2(j:k));
  end;
end;

% go back to full surf
for h=1:length(hemilist)
  vec_source = zeros(surfs(h).nverts,1);
  vec_source(surfs(h).decdips,:) = S0(surfs(h).decind);
  source{h} = vec_source;

  vec_spread = zeros(surfs(h).nverts,1);
  vec_spread(surfs(h).decdips,:) = S(surfs(h).decind);
  spread{h} = vec_spread;
end;

