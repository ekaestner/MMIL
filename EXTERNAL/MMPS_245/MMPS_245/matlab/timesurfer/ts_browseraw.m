function ts_browseraw(datafile, varargin);
% ts_browseraw(datafile,[options]) - browse raw data
%
% Purpose:
%  raw data browser with support for Neuromag fif format
%
% Usage: 
%  ts_browseraw(datafile, 'key1', value1 ...); % read from data file
%
% Display window interface:
%  "Activity plot" - [main window] This axis displays the channel activities.
%       For continuous data, the time axis shows time in seconds.
%  "Close" - [button] Closes the window and cancels any data rejection marks.
%  "Event types" - [button] pop up a legend window for events.
%  "<<" - [button] Scroll backwards though time by one window length.
%  "<"  - [button] Scroll backwards though time by 0.2 window length.
%  "Navigation edit box" - [edit box] Enter a starting time or epoch to jump to.
%  ">"  - [button] Scroll forward though time by 0.2 window length.
%  ">>" - [button] Scroll forward though time by one window length.
%  "Chan/Time/Value" - [text] If the mouse is within the activity window,
%       indicates to which channel, time, and activity value the cursor is
%       closest.
%  "Scale edit box" - [edit box] Scales the displayed amplitude in activity
%       units.  Command line equivalent: 'scaling' 
%  "+ / -" - [buttons] Use these buttons to +/- the amplitude scale by 10%. 
%  "Save" - [button] When pressed, save events (including rejection marks
%     and manual events).
%  "Clear" - [button] When pressed, clear manual rejection marks
%     and manual events from current window
% Required input:
%  datafile - full or relative pathname of raw data file
% Optional keywords:
%  'outfile' - output file name for mat file containing saved events
%     {default: "savedevents.mat"}
%  'readevents' - [0|1] Toggle read events from raw data
%     file.  Will also read header and get length of data file.
%     Makes prereadeof irrelevant.
%     {default: 0}
%  'prereadeof' - [0|1] Toggle get length of data file by reading
%     entire file (time consuming). Otherwise, risk core dump if you try
%     to jump past end of file.  Continuous browsing is safe either way.
%     Parameter is ignored if hdr is supplied or if readevents = on
%    {default: 0}
%  'events'     - [struct] event structure with the following fields:
%     events.type      = string (e.g. trigger, skip, reject, manual)
%     events.latency   = expressed in samples, first sample of file is 1
%     events.condition = numeric event code
%     events.duration  = expressed in samples
%  'hdr'        - [struct] hdr structure (see ts_read_fif_header)
%     hdr.sfreq           sampling frequency
%     hdr.nChans          number of channels
%     hdr.nSamples        number of samples per buffer
%     hdr.skips           vector of sample latencies for "skips"
%     hdr.tfirst          first time point in file
%     hdr.tlast           last time point in file
%     hdr.nBuffs          number of buffers in file (not including skips)
%     hdr.sensors         structure containing sensor information
%     if supplied, header will not be read from datafile unless readevents = 1
%  'minchan'    - first channel number to read
%     {default: 1}
%  'maxchan'    - last channel number to read
%     {default: inf}
%  'badchans'   - vector of channel numbers to exclude
%                 from display and artifact rejection
%     {default: []}
%  'badchanfile' - name of text file containing bad channel labels
%    {default: []}
%  'read_mag'   - [0|1] Toggle reading magnetometers (if in file)
%     {default: 1}
%  'read_grad1' - [0|1] Toggle reading gradiometers 1 (if in file)
%     {default: 1}
%  'read_grad2' - [0|1] Toggle reading gradiometers 2 (if in file)
%     {default: 1}
%  'read_eeg'   - [0|1] Toggle reading eeg channels (if in file)
%     {default: 1}
%  'read_eog'   - [0|1] Toggle reading eog channels (if in file)
%     {default: 1}
%  'read_other' - [0|1] Toggle reading other channels (if in file)
%     {default: 1}
%  'scale_mag'  - scale factor applied to magnetometer data
%     magnetometer data is prescaled by 10^15 into fT
%     the scaling controled by scale_mag is applied after this
%     {default: 0.5}
%  'scale_grad' - scale factor applied to gradiometer data
%     gradiometer data is prescaled by 10^13 into fT/cm
%     the scaling controled by scale_grad is applied after this
%     {default: 1}
%  'scale_eeg' - scale factor applied to EEG data
%     eeg data is prescaled by 10^6 into uV
%     the scaling controled by scale_eeg is applied after this
%     {default: 5}
%  'scale_eog' - scale factor applied to EOG data
%     EOG data is prescaled by 10^6 into uV
%     the scaling controled by scale_eog is applied after this
%     {default: 5}
%  'autoreject'  - [0|1] Toggle automatic artifact rejection
%     {default: 1}
%  'reject_mag'  - automatic rejection threshold for magnetometer channels (fT)
%     if 0, rejection based on magnetometers is disabled
%     {default: 6000}
%  'reject_grad' - automatic rejection threshold for gradiometer channels (fT/cm)
%     if 0, rejection based on gradiometers is disabled
%     {default: 3000}
%  'reject_eeg' - automatic rejection threshold for eeg channels (uV)
%     if 0, rejection based on eeg is disabled
%     {default: 0}
%  'reject_eog' - automatic rejection threshold for eog channel (uV)
%     if -1, rejection based on eog is disabled
%     {default: 200}
%  'prestim_dur' - duration of prestimulus period (msec)
%     used for displaying automatic artifact rejection
%     {default: 100}
%  'poststim_dur' - duration of poststimulus period (msec)
%     used for displaying automatic artifact rejection
%     {default: 300}
%  'filter'       - [0|1] Toggle bandpass frequency filter
%     Data will be detrended before filtering
%     {default: 0}
%  'filter_low_cf'  - low center frequency (high-pass filter) (Hz)
%     {default: 0.2}
%  'filter_low_tb'  - low transition band (Hz)
%     {default: 0.4}
%  'filter_high_cf' - high center frequency (low-pass filter) (Hz)
%     {default: 100}
%  'filter_high_tb' - high transition band (Hz)
%     {default: 10}
%  'filter_notch' - [0|1] Toggle notch frequency filter
%     Data will be detrended before filtering
%     {default: 0}
%  'filter_notch_cf'  - notch center frequency (high-pass filter) (Hz)
%     {default: 60}
%  'filter_notch_tb'  - notch transition band (Hz)
%     {default: 4}
%  'dsfact' - downsampling factor -- may make display of data faster
%     {default: 1 (no downsampling)}
%  'scaling'    - Scaling factor
%     {default: 0 (max(data)-min(data)}
%  'winlength'  - [value] Seconds of data to display in window {default: 5}
%  'dispchans'  - [integer] Number of channels to display in the activity window
%     {default: all}.  If < total number of channels, a vertical slider
%     on the left side of the figure allows vertical data scrolling
%  'chanlabels' - [0|1] Toggle display of channel labels (or just numbers)
%     {default: 0}
%  'xgrid'      - [0|1] Toggle display of the x-axis grid
%     {default: 0}
%  'ygrid'      - [0|1] Toggle display of the y-axis grid
%     {default: 0}
%  'ploteventdur' - [0|1] Toggle display of event duration
%     {default: 1}
%  'color'      - [0|1|cell array] Plot channels with different colors.
%     Entering a RGB cell array {'r' 'b' 'g'}, channels will be plotted using
%     the cell-array color elements
%     {default: 0}. 
%  'wincolor'   - [color] Color mark data stretches  
%     {default: [ 0.8345 1 0.956]}
%  'submean'    - [0|1] Remove channel means in each window
%     Irrelevant if filter=1 since detrending will be done before filtering
%     {default: 1}
%  'position'   - [lowleft_x lowleft_y width height] Position of the figure in
%     pixels.
%  'tag'        - [string] Matlab object tag to identify this ts_browseraw()
%     window (allows keeping track of several simultaneous ts_browseraw() windows). 
%  'children'   - [integer] Figure handle of a *dependent* ts_browseraw() window.
%     Scrolling horizontally in the master window will produce the same
%     scroll in the dependent window. Allows comparison of two concurrent
%     datasets.
%  'scale'      - [0|1] Display the amplitude scale
%     {default: 1}
%  'report_progress' - [0|1] Write messages to console with elapsed time for reading, drawing, etc.
%     {default: 0}
% Outputs:
%  savedevents  -  Event structure (same format as 'events' above) created
%     when the SAVE button is clicked. 
%
% created:   04/04/06 by Don Hagler
% last mod:  02/09/12 by Don Hagler
%
% See also: eegplot()
%




%% Truncated copyright info from eegplot:
% Copyright (C) 2001 Arnaud Delorme & Colin Humphries, Salk Institute, arno@salk.edu
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2 of the License, or
% (at your option) any later version.
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

% ts_browseraw branch 04/04/06 by Don Hagler, MMIL UCSD (dhagler@ucsd.edu)
% version 0.1.0
% ---------------------------------------------------------------------- 
% based on EEGLAB's eegplot
% Revision 1.1  2002/04/05 17:39:45  jorn
% 4/01 version 3 Arnaud Delorme, CNL / Salk Institute, La Jolla CA (arno@salk.edu)
% from an original version by Colin Humphries, 5/98  
% CNL / Salk Institute, La Jolla CA (colin@salk.edu) 
% ---------------------------------------------------------------------- 


%% todo: add checkbox to hold reading/drawing


%% todo: subsets of channels based on location on head (frontal, temporal, etc.)
%% todo: scalefact for 'other' channels?
%% todo: ECG getting classified as EOG -- can they be distinguished?
%% todo: make xgrid spacing a function of winlength
%% todo: scan through file (autoadvance)
%% todo: add back zoom?
%% todo: skip to events
%% todo: hotkeys for things like reject epoch
%% todo: rereference (bipolar)


DEFAULT_PLOT_COLOR = {[0 0 1], [0.7 0.7 0.7]};         % EEG line color
DEFAULT_FIG_COLOR = [0.6 0.6 0.6];
BUTTON_COLOR =[0.8 0.8 0.8];
DEFAULT_LINE_COLOR = [0 0 0];     % vertical line color
DEFAULT_AXIS_COLOR = 'k';         % X-axis, Y-axis Color, text Color
DEFAULT_GRID_SPACING = 1;         % Grid lines every n seconds
DEFAULT_GRID_STYLE = '-';         % Grid line style
%DEFAULT_AXES_POSITION = [0.07 0.09 0.62  0.87]; % dimensions of main EEG axes
DEFAULT_AXES_POSITION = [0.07 0.09 0.62  0.87]; % dimensions of main EEG axes
LABELS_AXES_POSITION =  [0.12 0.09 0.57  0.87];
PRESCALE_MAG = 10^15;  % to fT
PRESCALE_GRAD = 10^13; % to fT/cm
PRESCALE_EEG = 10^6;   % to uV
PRESCALE_EOG = 10^6;   % to uV
MAX_WINLENGTH = 20; % seconds

if nargin < 1
   help(mfilename);
   return
end
                  
% %%%%%%%%%%%%%%%%%%%%%%%%
% Setup inputs
% %%%%%%%%%%%%%%%%%%%%%%%%

callbacks = {'drawp' 'drawb' 'draws' 'updateevents' 'initevents'...
             'setchanlabels' 'zoom' 'updateslider' 'drawlegend' 'readfile'...
             'clearmanual' 'sortevents' 'clearrejects' 'findartifacts'...
             'scaledata' 'downsampdata' 'filterdata'...
             'setreadchans' 'mouseclickdown' 'mousemove'};

if ~ismember(datafile,callbacks)
  if(~exist(datafile,'file'))
    fprintf('%s: datafile %s not found\n',mfilename,datafile);
    return;
  end

  if (~mmil_check_nargs(nargin,1)) return; end;
  parms = mmil_args2parms(varargin, {...
    'title','Browse Raw Data',[],...
    'outfile','savedevents.mat',[],...
    'scaling',0,[0 Inf],...
    'spacing',0,[0 Inf],...
    'position',[150 250 800 500],[],...
    'tag',mfilename,[],...
    'children',0,[],...
    'wincolor',[0.8345 1 0.9560],[],...
    'showlabels',false,[false true],...
    'xgrid',false,[false true],...
    'ygrid',false,[false true],...
    'color',false,[false true],...
    'submean',false,[false true],...
    'scale',true,[false true],...
    'readevents',false,[false true],...
    'events',[],[],...
    'hdr',[],[],...
    'ploteventdur',true,[false true],...
    'minchan',0,[0 Inf],...
    'maxchan',Inf,[0 Inf],...
    'badchans',[],[],...
    'badchanfile',[],[],...
    'dispchans',20,[0 Inf],...
    'winlength',5,[0 MAX_WINLENGTH],...
    'prereadeof',false,[false true],...
    'read_mag',true,[false true],...
    'read_grad1',true,[false true],...
    'read_grad2',true,[false true],...
    'read_eeg',true,[false true],...
    'read_eog',true,[false true],...
    'read_other',true,[false true],...
    'scale_mag',0.5,[],...
    'scale_grad',1,[],...
    'scale_eeg',5,[],...
    'scale_eog',5,[],...
    'autoreject',true,[false true],...
    'reject_mag',6000,[],...
    'reject_grad',3000,[],...
    'reject_eeg',0,[],...
    'reject_eog',200,[],...
    'prestim_dur',100,[],...
    'poststim_dur',300,[],...
    'filter',true,[false true],...
    'filter_notch',true,[false true],...
    'filter_low_cf',0.2,[],...
    'filter_low_tb',0.4,[],...
    'filter_high_cf',100,[],...
    'filter_high_tb',10,[],...
    'filter_notch_cf',60,[],...
    'filter_notch_tb',4,[],...
    'dsfact',1,[1 1000],...
    'report_progress',false,[false true],...
 });

  % reject bad parameters
  strlen = length(parms.outfile);
  if ~strcmp('.mat',parms.outfile(strlen-3:strlen))
    parms.outfile = [parms.outfile '.mat'];
  end;
  if isstr(parms.tag) > 1
    error('tag must be is a string');
  end;    
  if length(parms.position) ~= 4
    error('position must be is a 4 elements array');
  end;    
  if ~iscell(parms.color)
    if parms.color
      parms.color = {'k', 'm', 'c', 'b', 'g'}; 
    else
      parms.color = {[ 0 0 0.4]};  
    end;
  end;

  if parms.scaling>0
    parms.spacing = 1000/parms.scaling;
  end;

  % load header
  parms.datafile = datafile;
  % winlength = seconds of data read and displayed
  parms.maxwinlength = MAX_WINLENGTH;
  parms.rawbegtime = 0;
  parms.rawendtime = parms.rawbegtime + parms.winlength;
  if(parms.readevents)
    fprintf('reading events for %s...\n',parms.datafile);
    [parms.hdr,tmpevents]=ts_read_fif_events(parms.datafile);
    parms.events = [parms.events,tmpevents];
  elseif(isempty(parms.hdr))
    fprintf('reading header for %s...\n',parms.datafile);
    if(parms.prereadeof)
      fprintf('this may take awhile...\n',parms.datafile);
      parms.hdr = ts_read_fif_header(parms.datafile,1);
    else
      fprintf('not getting file length (prereadeof = false), so be careful!\n');
      parms.hdr = ts_read_fif_header(parms.datafile,0);
    end
  end

  if ~isempty(parms.badchanfile)
    % read badchan file
    labels = parms.hdr.sensors.label; 
    badchan_i = ts_read_txt_badchans(parms.badchanfile,labels);
    parms.badchans = unique([parms.badchans,badchan_i]);
  end;

  parms.orig_frames = round(parms.winlength*parms.hdr.sfreq);
  parms.sfreq = parms.hdr.sfreq/parms.dsfact;
  parms.frames = round(parms.winlength*parms.sfreq);
  % prestim and poststim for artifact rejection
  parms.prestim_samp  = round(parms.prestim_dur  * parms.sfreq/1000); % convert from msec to samples
  parms.poststim_samp = round(parms.poststim_dur * parms.sfreq/1000); % convert from msec to samples
  parms.winstatus = 1;
  parms.setchannel  = 0;
  parms.chanoffset = 0;
  parms.plotevent = 1;
  parms.manual_reject = 1;
  parms.manual_event = 0;
  parms.manual_event_code = 1;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Prepare figure and axes
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  figh = figure('UserData', parms,... % store the settings here
     'Color',DEFAULT_FIG_COLOR, 'name', parms.title, ...
     'MenuBar','none','tag', parms.tag ,'Position',parms.position,...
     'numbertitle', 'off', 'visible', 'off');

  % set channels for reading
  ts_browseraw('setreadchans');
  parms = get(figh,'UserData');

  pos = get(figh,'position'); % plot relative to current axes
  q = [pos(1) pos(2) 0 0];
  s = [pos(3) pos(4) pos(3) pos(4)]./100;
  clf;

  % Background axis
  % --------------- 
  ax0 = axes('tag','UI_backaxis','parent',figh,...
     'Position',DEFAULT_AXES_POSITION,...
     'Box','off','xgrid','off', 'xaxislocation', 'top'); 

  % Data axis
  % --------------- 
  YLabels = num2str(parms.readchans'); % use chan numbers by default
  YLabels = flipud(str2mat(YLabels,' '));
  data = zeros(parms.chans,parms.frames);
  ax1 = axes('Position',DEFAULT_AXES_POSITION,...
     'userdata', data, ...% store the data here (when in g, slow down display)
     'tag','UI_dataaxis','parent',figh,...
     'Box','on','xgrid', fastif(parms.xgrid,'on','off'),...
     'ygrid', fastif(parms.ygrid,'on','off'),...
     'gridlinestyle',DEFAULT_GRID_STYLE,...
     'Xlim',[0 parms.winlength*parms.sfreq],...
     'xtick',[0:parms.sfreq*DEFAULT_GRID_SPACING:parms.winlength*parms.sfreq],...
     'Ylim',[0 (parms.chans+1)],...
     'YTick',[0:1:parms.chans],...
     'YTickLabel', YLabels,...
     'XTickLabel',num2str((0:DEFAULT_GRID_SPACING:parms.winlength)'),...
     'TickLength',[.005 .005],...
     'Color','none',...
     'XColor',DEFAULT_AXIS_COLOR,...
     'YColor',DEFAULT_AXIS_COLOR);

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Set up uicontrols
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  % lower left corners of uicontrol groups
  ui_slider      = [0.02,DEFAULT_AXES_POSITION(2)];
  ui_buttons     = [0.70,0.02];
  ui_timestep    = [0.08,0.0];
  ui_scaling     = [0.70,0.45];
  ui_value       = [0.29,0.0];
  ui_downsamp    = [0.70,0.35];
  ui_filter      = [0.70,0.08];
  ui_autoreject  = [0.83,0.34];
  ui_scale       = [0.94,0.34];
  ui_read        = [0.83,0.55];
  ui_display     = [0.83,0.74];
  ui_manual      = [0.70,0.74];

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Slider for vertical motion
  ui_offset = ui_slider;

  % set positions
  n=1;
  uipos(n,:)  = [ 0.0 0.0 0.015 DEFAULT_AXES_POSITION(4) ]; n=n+1; % slider
  uipos(1:n-1,1) = uipos(1:n-1,1) + ui_offset(1);
  uipos(1:n-1,2) = uipos(1:n-1,2) + ui_offset(2);
  
  % define commands
  slider_cmd = [...
    'tmpparms = get(gcbf, ''userdata'');' ... 
    'tmpparms.chanoffset = get(gcbo, ''value'')*(tmpparms.chans-tmpparms.actualdispchans);' ...
    'set(gcbf, ''userdata'', tmpparms);' ...
    'ts_browseraw(''drawp'',0);' ...
    'clear tmpparms;'...
  ];

  % create uicontrols
  n=1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Style','slider', ...
   'visible', 'off', ...
   'sliderstep', [0.9 1], ...
   'Tag','UI_slider', ...
   'callback',slider_cmd,...
   'value', 0);

  clear uipos u;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % buttons group
  ui_offset = ui_buttons;

  % set positions
  n=1;
  uipos(n,:)  = [ 0.20      -0.01      0.09     0.05   ]; n=n+1; % close
  uipos(n,:)  = [ 0.01       0.53      0.09     0.05   ]; n=n+1; % save events
  uipos(n,:)  = [ 0.01       0.58      0.09     0.05   ]; n=n+1; % legend
  uipos(n,:)  = [ 0.01       0.63      0.09     0.05   ]; n=n+1; % clear
  uipos(n,:)  = [ 0.01       0.68      0.09     0.05   ]; n=n+1; % reject
  uipos(1:n-1,1) = uipos(1:n-1,1) + ui_offset(1);
  uipos(1:n-1,2) = uipos(1:n-1,2) + ui_offset(2);

  % define commands
  close_cmd = [...
    'parms = get(gcbf, ''userdata'');'... 
    'if parms.children, delete(parms.children); end;'...
    'close(gcbf);'...
  ];
  save_cmd = [...
    'ts_browseraw(''clearrejects'');'...
    'ts_browseraw(''sortevents'');'...
    'parms = get(gcbf, ''userdata'');'...
    'keep = find(cell2mat({parms.events.duration})~=0);'...
    'parms.events = parms.events(keep);'...
    'evnts = parms.events;'...
    'hdr = parms.hdr;'...
    'save(parms.outfile, ''evnts'', ''hdr'');'...
    'set(gcbf,''userdata'', parms);' ...
    'ts_browseraw(''initevents'');'...
    'ts_browseraw(''findartifacts'');'...
  ];
  reject_cmd = [...
    'parms = get(gcbf, ''userdata'');' ...
    'tmp_beg_samp = parms.rawbegtime*parms.hdr.sfreq + 1;'...
    'tmp_end_samp = parms.rawendtime*parms.hdr.sfreq;'...
    'parms.events(end+1).type = ''reject'';'...
    'parms.events(end  ).latency = tmp_beg_samp;'...
    'parms.events(end  ).condition = 0;'...
    'parms.events(end  ).duration = tmp_end_samp - tmp_beg_samp;'...
    'parms.tmpevent.latency=0;'...
    'parms.tmpevent.duration=0;'...
    'set(gcbf,''UserData'', parms);' ...
    'ts_browseraw(''updateevents'');'...
    'ts_browseraw(''drawb'');'...
    'clear tmp_beg_samp tmp_end_samp;'...
  ];
  clear_cmd = [...
    'ts_browseraw(''clearmanual'');'...
    'ts_browseraw(''updateevents'');'...
    'ts_browseraw(''drawb'');'...
  ];

  % create uicontrols
  n=1;
  % close button
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Tag','UI_close',...
   'string','CLOSE',...
   'callback', close_cmd);
  n=n+1;
  % save events button
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Tag','UI_save',...
   'TooltipString','Save events and rejects',...
   'string','Save',...
   'callback', save_cmd);
  n=n+1;
  % legend button
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Tag','UI_events',...
   'TooltipString','Display event type legend',...
   'string', 'Legend',...
   'callback', 'ts_browseraw(''drawlegend'', gcbf)');
  n=n+1;
  % clear manual button
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Tag','UI_clear',...
   'TooltipString','Clear manual rejects and events for current epoch',...
   'string','Clear',...
   'callback', clear_cmd);
  n=n+1;
  % reject button
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Tag','UI_reject',...
   'TooltipString','Reject current epoch',...
   'string','Reject',...
   'callback', reject_cmd);
  n=n+1;

  clear uipos u;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % timestep group
  ui_offset = ui_timestep;

  % set positions
  n=1;
  uipos(n,:)  = [ 0.00      0.01    0.0385    0.039 ]; n=n+1; % <<
  uipos(n,:)  = [ 0.04      0.01    0.0288    0.039 ]; n=n+1; % <
  uipos(n,:)  = [ 0.0705    0.01    0.0561    0.039 ]; n=n+1; % Eposition
  uipos(n,:)  = [ 0.13      0.01    0.0299    0.039 ]; n=n+1; % >
  uipos(n,:)  = [ 0.16      0.01    0.0385    0.039 ]; n=n+1; % >>
  uipos(1:n-1,1) = uipos(1:n-1,1) + ui_offset(1);
  uipos(1:n-1,2) = uipos(1:n-1,2) + ui_offset(2);
  
  % create uicontrols
  n=1;
  % Five move buttons: << < text > >> 
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Tag','UI_jumpback',...
   'TooltipString','jump back',...
   'string','<<',...
   'Callback','ts_browseraw(''drawp'',1)');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Tag','UI_stepback',...
   'TooltipString','step back',...
   'string','<',...
   'Callback','ts_browseraw(''drawp'',2)');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_position',...
   'TooltipString','select time',...
   'string', 0,...
   'Callback', 'ts_browseraw(''drawp'',0);' );
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Tag','UI_stepforward',...
   'TooltipString','step forward',...
   'string','>',...
   'Callback','ts_browseraw(''drawp'',3)');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Tag','UI_jumpforward',...
   'TooltipString','jump forward',...
   'string','>>',...
   'Callback','ts_browseraw(''drawp'',4)');

  clear uipos u;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % read group
  ui_offset = ui_read;

%% todo: make a single column, under button group
  % set positions
  n=1;
  uipos(n,:) = [ 0.00      0.13      0.08      0.039  ]; n=n+1; % read_mag
  uipos(n,:) = [ 0.00      0.09      0.08      0.039  ]; n=n+1; % read_grad1
  uipos(n,:) = [ 0.00      0.05      0.08      0.039  ]; n=n+1; % read_grad2
  uipos(n,:) = [ 0.08      0.13      0.08      0.039  ]; n=n+1; % read_eeg
  uipos(n,:) = [ 0.08      0.09      0.08      0.039  ]; n=n+1; % read_eog
  uipos(n,:) = [ 0.08      0.05      0.08      0.039  ]; n=n+1; % read_other
  uipos(n,:) = [ 0.00      0.005     0.04      0.039  ]; n=n+1; % min_chan label
  uipos(n,:) = [ 0.04      0.01      0.04      0.039  ]; n=n+1; % min_chan
  uipos(n,:) = [ 0.08      0.005     0.04      0.039  ]; n=n+1; % max_chan label
  uipos(n,:) = [ 0.12      0.01      0.04      0.039  ]; n=n+1; % max_chan
  uipos(1:n-1,1) = uipos(1:n-1,1) + ui_offset(1);
  uipos(1:n-1,2) = uipos(1:n-1,2) + ui_offset(2);

  % define commands
  read_cmd = [ ...
    'parms = get(gcbf, ''userdata'');' ...
    'parms.read_mag   = get(findobj(gcbf, ''tag'', ''UI_read_mag''),''value'');'...
    'parms.read_grad1 = get(findobj(gcbf, ''tag'', ''UI_read_grad1''),''value'');'...
    'parms.read_grad2 = get(findobj(gcbf, ''tag'', ''UI_read_grad2''),''value'');'...
    'parms.read_eeg   = get(findobj(gcbf, ''tag'', ''UI_read_eeg''),''value'');'...
    'parms.read_eog   = get(findobj(gcbf, ''tag'', ''UI_read_eog''),''value'');'...
    'parms.read_other = get(findobj(gcbf, ''tag'', ''UI_read_other''),''value'');'...
    'tmp_minchan  = str2num(get(findobj(gcbf, ''tag'', ''UI_minchan''),''string''));'...
    'tmp_maxchan  = str2num(get(findobj(gcbf, ''tag'', ''UI_maxchan''),''string''));'...
    'if size(tmp_minchan)==1 & tmp_minchan>0'...
    '  parms.minchan = round(tmp_minchan);'...
    'end;'...
    'set(findobj(gcbf, ''tag'', ''UI_minchan''),''string'',num2str(parms.minchan));'...
    'if size(tmp_maxchan)==1 & tmp_maxchan>0'...
    '  parms.maxchan = round(tmp_maxchan);'...
    'end;'...
    'set(findobj(gcbf, ''tag'', ''UI_maxchan''),''string'',num2str(parms.maxchan));'...
    'set(gcbf, ''userdata'', parms);' ...
    'ts_browseraw(''setreadchans'');'...
    'ts_browseraw(''setchanlabels'');'...
    'ts_browseraw(''readfile'');'...
    'ts_browseraw(''updateevents'');'...
    'ts_browseraw(''updateslider'', gcbf);'...
    'ts_browseraw(''drawp'',0);'...
    'clear tmp_minchan tmp_maxchan;'...
  ];
  
  % create uicontrols
  n=1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_read_mag',...
   'TooltipString','read magnetometer channels',...
   'HorizontalAlignment', 'left',...
   'callback', read_cmd,...
   'value', parms.read_mag,...
   'string','Mag');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_read_grad1',...
   'TooltipString','read gradiometer 1 channels',...
   'HorizontalAlignment', 'left',...
   'callback', read_cmd,...
   'value', parms.read_grad1,...
   'string','Grad1');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_read_grad2',...
   'TooltipString','read gradiometer 2 channels',...
   'HorizontalAlignment', 'left',...
   'callback', read_cmd,...
   'value', parms.read_grad2,...
   'string','Grad2');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_read_eeg',...
   'TooltipString','read EEG channels',...
   'HorizontalAlignment', 'left',...
   'callback', read_cmd,...
   'value', parms.read_eeg,...
   'string','EEG');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_read_eog',...
   'TooltipString','read EOG channels',...
   'HorizontalAlignment', 'left',...
   'callback', read_cmd,...
   'value', parms.read_eog,...
   'string','EOG');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_read_other',...
   'TooltipString','read other channels',...
   'HorizontalAlignment', 'left',...
   'callback', read_cmd,...
   'value', parms.read_other,...
   'string','Other');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_minchan_label',...
   'HorizontalAlignment', 'left',...
   'string','min');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_minchan',...
   'TooltipString','minimum channel number to read',...
   'HorizontalAlignment', 'left',...
   'callback', read_cmd,...
   'string',num2str(parms.minchan));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_maxchan_label',...
   'HorizontalAlignment', 'left',...
   'string','max');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_maxchan',...
   'TooltipString','maximum channel number to read',...
   'HorizontalAlignment', 'left',...
   'callback', read_cmd,...
   'string',num2str(parms.maxchan));
  n=n+1;

  clear uipos u;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % autoreject group
  ui_offset = ui_autoreject;

  % set positions
  n=1;
  uipos(n,:) = [ 0.0       0.16      0.11      0.039  ]; n=n+1; % autoreject
  uipos(n,:) = [ 0.042     0.12      0.05      0.039  ]; n=n+1; % reject_mag
  uipos(n,:) = [ 0.042     0.08      0.05      0.039  ]; n=n+1; % reject_grad
  uipos(n,:) = [ 0.042     0.04      0.05      0.039  ]; n=n+1; % reject_eeg
  uipos(n,:) = [ 0.042     0.00      0.05      0.039  ]; n=n+1; % reject_eog
  uipos(n,:) = [ 0.0       0.12      0.042     0.031  ]; n=n+1; % reject_mag label
  uipos(n,:) = [ 0.0       0.08      0.042     0.031  ]; n=n+1; % reject_grad label
  uipos(n,:) = [ 0.0       0.04      0.042     0.031  ]; n=n+1; % reject_eeg label
  uipos(n,:) = [ 0.0       0.00      0.042     0.031  ]; n=n+1; % reject_eog label
  uipos(n,:) = [ 0.00     -0.04      0.035     0.031  ]; n=n+1; % prestim_dur label
  uipos(n,:) = [ 0.03     -0.04      0.045     0.039  ]; n=n+1; % prestim_dur
  uipos(n,:) = [ 0.075    -0.04      0.04      0.031  ]; n=n+1; % poststim_dur label
  uipos(n,:) = [ 0.115    -0.04      0.045     0.039  ]; n=n+1; % poststim_dur
  uipos(1:n-1,1) = uipos(1:n-1,1) + ui_offset(1);
  uipos(1:n-1,2) = uipos(1:n-1,2) + ui_offset(2);

  % define commands
  autoreject_cmd = [ ...
    'parms = get(gcbf, ''userdata'');' ...
    'tmp_autoreject = parms.autoreject;'...
    'parms.autoreject  = get(findobj(gcbf, ''tag'', ''UI_autoreject''),''value'');'...
    'tmp_reject_mag  = str2num(get(findobj(gcbf, ''tag'', ''UI_reject_mag''),''string''));'...
    'tmp_reject_grad = str2num(get(findobj(gcbf, ''tag'', ''UI_reject_grad''),''string''));'...
    'tmp_reject_eeg  = str2num(get(findobj(gcbf, ''tag'', ''UI_reject_eeg''),''string''));'...
    'tmp_reject_eog  = str2num(get(findobj(gcbf, ''tag'', ''UI_reject_eog''),''string''));'...
    'tmp_prestim_dur  = str2num(get(findobj(gcbf, ''tag'', ''UI_prestim_dur''),''string''));'...
    'tmp_poststim_dur  = str2num(get(findobj(gcbf, ''tag'', ''UI_poststim_dur''),''string''));'...
    'if size(tmp_reject_mag)~=1 | tmp_reject_mag<0'...
    '  set(findobj(gcbf, ''tag'', ''UI_reject_mag''),''string'',num2str(parms.reject_mag));'...
    'else'...
    '  parms.reject_mag = tmp_reject_mag;'...
    'end;'...
    'if size(tmp_reject_grad)~=1 | tmp_reject_grad<0'...
    '  set(findobj(gcbf, ''tag'', ''UI_reject_grad''),''string'',num2str(parms.reject_grad));'...
    'else'...
    '  parms.reject_grad = tmp_reject_grad;'...
    'end;'...
    'if size(tmp_reject_eeg)~=1 | tmp_reject_eeg<0'...
    '  set(findobj(gcbf, ''tag'', ''UI_reject_eeg''),''string'',num2str(parms.reject_eeg));'...
    'else'...
    '  parms.reject_eeg = tmp_reject_eeg;'...
    'end;'...
    'if size(tmp_reject_eog)~=1 | tmp_reject_eog<0'...
    '  set(findobj(gcbf, ''tag'', ''UI_reject_eog''),''string'',num2str(parms.reject_eog));'...
    'else'...
    '  parms.reject_eog = tmp_reject_eog;'...
    'end;'...
    'if size(tmp_prestim_dur)==1 & tmp_prestim_dur>=0'...
    '  parms.prestim_dur = tmp_prestim_dur;'...
    '  parms.prestim_samp = round(tmp_prestim_dur*parms.sfreq/1000);'...
    'end;'...
    'set(findobj(gcbf, ''tag'', ''UI_prestim_dur''),''string'',num2str(parms.prestim_dur));'...
    'if size(tmp_poststim_dur)==1 & tmp_poststim_dur>=0'...
    '  parms.poststim_dur = tmp_poststim_dur;'...
    '  parms.poststim_samp = round(tmp_poststim_dur*parms.sfreq/1000);'...
    'end;'...
    'set(findobj(gcbf, ''tag'', ''UI_poststim_dur''),''string'',num2str(parms.poststim_dur));'...
    'set(gcbf, ''userdata'', parms);' ...
    'if tmp_autoreject | parms.autoreject'...
    '  ts_browseraw(''clearrejects'');'...
    '  ts_browseraw(''findartifacts'');'...
    '  ts_browseraw(''updateevents'');'...
    '  ts_browseraw(''drawp'',0);'...
    'end;'...
    'clear tmp_autoreject tmp_reject_mag tmp_reject_grad tmp_reject_eeg tmp_reject_eog;'...
    'clear tmp_poststimdur tmp_prestim_dur;'...
  ];

  % create uicontrols
  n=1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_autoreject',...
   'TooltipString','automatically mark rejected epochs',...
   'HorizontalAlignment', 'right',...
   'callback', autoreject_cmd,...
   'value', parms.autoreject,...
   'string','AutoReject');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_reject_mag',...
   'TooltipString','magnetometer rejection threshold (fT)',...
   'HorizontalAlignment', 'left',...
   'callback', autoreject_cmd,...
   'string',num2str(parms.reject_mag));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_reject_grad',...
   'TooltipString','gradiometer rejection threshold (fT/cm)',...
   'HorizontalAlignment', 'left',...
   'callback', autoreject_cmd,...
   'string',num2str(parms.reject_grad));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_reject_eeg',...
   'TooltipString','EEG rejection threshold (uV)',...
   'HorizontalAlignment', 'left',...
   'callback', autoreject_cmd,...
   'string',num2str(parms.reject_eeg));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_reject_eog',...
   'TooltipString','EOG rejection threshold (uV)',...
   'HorizontalAlignment', 'left',...
   'callback', autoreject_cmd,...
   'string',num2str(parms.reject_eog));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_reject_mag_label',...
   'HorizontalAlignment', 'left',...
   'string','Mag');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_reject_grad_label',...
   'HorizontalAlignment', 'left',...
   'string','Grad');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_reject_eeg_label',...
   'HorizontalAlignment', 'left',...
   'string','EEG');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_reject_eog_label',...
   'HorizontalAlignment', 'left',...
   'string','EOG');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_prestim_dur_label',...
   'HorizontalAlignment', 'left',...
   'string','pre');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_prestim_dur',...
   'TooltipString','pre-stimulus duration (msec)',...
   'HorizontalAlignment', 'left',...
   'callback', autoreject_cmd,...
   'string',num2str(parms.prestim_dur));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_poststim_dur_label',...
   'HorizontalAlignment', 'left',...
   'string','post');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_poststim_dur',...
   'TooltipString','post-stimulus duration (msec)',...
   'HorizontalAlignment', 'left',...
   'callback', autoreject_cmd,...
   'string',num2str(parms.poststim_dur));
  n=n+1;

  clear uipos u;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % scale group
  ui_offset = ui_scale;

  % set positions
  n=1;
  uipos(n,:) = [ 0.00      0.16      0.05      0.031  ]; n=n+1; % scale label
  uipos(n,:) = [ 0.00      0.12      0.05      0.039  ]; n=n+1; % scale_mag
  uipos(n,:) = [ 0.00      0.08      0.05      0.039  ]; n=n+1; % scale_grad
  uipos(n,:) = [ 0.00      0.04      0.05      0.039  ]; n=n+1; % scale_eeg
  uipos(n,:) = [ 0.00      0.00      0.05      0.039  ]; n=n+1; % scale_eog
  uipos(1:n-1,1) = uipos(1:n-1,1) + ui_offset(1);
  uipos(1:n-1,2) = uipos(1:n-1,2) + ui_offset(2);

  % define commands
  scale_cmd = [ ...
    'parms = get(gcbf, ''userdata'');' ...
    'tmp_scale_mag  = str2num(get(findobj(gcbf, ''tag'', ''UI_scale_mag''),''string''));'...
    'tmp_scale_grad = str2num(get(findobj(gcbf, ''tag'', ''UI_scale_grad''),''string''));'...
    'tmp_scale_eeg  = str2num(get(findobj(gcbf, ''tag'', ''UI_scale_eeg''),''string''));'...
    'tmp_scale_eog  = str2num(get(findobj(gcbf, ''tag'', ''UI_scale_eog''),''string''));'...
    'if size(tmp_scale_mag)~=1 | tmp_scale_mag <0'...
    '  set(findobj(gcbf, ''tag'', ''UI_scale_mag''),''string'',num2str(parms.scale_mag));'...
    'else'...
    '  parms.scale_mag = tmp_scale_mag;'...
    'end;'...
    'if size(tmp_scale_grad)~=1 | tmp_scale_grad <0'...
    '  set(findobj(gcbf, ''tag'', ''UI_scale_grad''),''string'',num2str(parms.scale_grad));'...
    'else'...
    '  parms.scale_grad = tmp_scale_grad;'...
    'end;'...
    'if size(tmp_scale_eeg)~=1 | tmp_scale_eeg <0'...
    '  set(findobj(gcbf, ''tag'', ''UI_scale_eeg''),''string'',num2str(parms.scale_eeg));'...
    'else'...
    '  parms.scale_eeg = tmp_scale_eeg;'...
    'end;'...
    'if size(tmp_scale_eog)~=1 | tmp_scale_eog <0'...
    '  set(findobj(gcbf, ''tag'', ''UI_scale_eog''),''string'',num2str(parms.scale_eog));'...
    'else'...
    '  parms.scale_eog = tmp_scale_eog;'...
    'end;'...
    'set(gcbf, ''userdata'', parms);' ...
    'ts_browseraw(''readfile'');'...
    'ts_browseraw(''updateevents'');'...
    'ts_browseraw(''drawp'',0);'...
    'clear tmp_scale_mag tmp_scale_grad tmp_scale_eeg tmp_scale_eog;'...
  ];

  % create uicontrols
  n=1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_scale_label',...
   'HorizontalAlignment', 'left',...
   'string','Scale');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_scale_mag',...
   'TooltipString','magnetometer display scale factor',...
   'HorizontalAlignment', 'left',...
   'callback', scale_cmd,...
   'string',num2str(parms.scale_mag));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_scale_grad',...
   'TooltipString','gradiometer display scale factor',...
   'HorizontalAlignment', 'left',...
   'callback', scale_cmd,...
   'string',num2str(parms.scale_grad));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_scale_eeg',...
   'TooltipString','EEG display scale factor',...
   'HorizontalAlignment', 'left',...
   'callback', scale_cmd,...
   'string',num2str(parms.scale_eeg));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_scale_eog',...
   'TooltipString','EOG display scale factor',...
   'HorizontalAlignment', 'left',...
   'callback', scale_cmd,...
   'string',num2str(parms.scale_eog));
  n=n+1;

  clear uipos u;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % filter group
  ui_offset = ui_filter;

  % set positions
  n=1;
  uipos(n,:) = [ 0.12      0.13      0.12      0.04   ]; n=n+1; % filter label
  uipos(n,:) = [ 0.0       0.07      0.12      0.039  ]; n=n+1; % filter
  uipos(n,:) = [ 0.0       0.02      0.12      0.039  ]; n=n+1; % filter_notch
  uipos(n,:) = [ 0.17      0.08      0.05      0.039  ]; n=n+1; % filter_low_cf
  uipos(n,:) = [ 0.24      0.08      0.05      0.039  ]; n=n+1; % filter_low_tb
  uipos(n,:) = [ 0.17      0.04      0.05      0.039  ]; n=n+1; % filter_high_cf
  uipos(n,:) = [ 0.24      0.04      0.05      0.039  ]; n=n+1; % filter_high_tb
  uipos(n,:) = [ 0.17      0.00      0.05      0.039  ]; n=n+1; % filter_notch_cf
  uipos(n,:) = [ 0.24      0.00      0.05      0.039  ]; n=n+1; % filter_notch_tb
  uipos(n,:) = [ 0.13      0.08      0.04      0.03   ]; n=n+1; % low label
  uipos(n,:) = [ 0.13      0.04      0.04      0.03   ]; n=n+1; % high label
  uipos(n,:) = [ 0.13      0.00      0.04      0.03   ]; n=n+1; % notch label
  uipos(n,:) = [ 0.165     0.115     0.06      0.03   ]; n=n+1; % center label
  uipos(n,:) = [ 0.23      0.115     0.07      0.03   ]; n=n+1; % trans label
  uipos(1:n-1,1) = uipos(1:n-1,1) + ui_offset(1);
  uipos(1:n-1,2) = uipos(1:n-1,2) + ui_offset(2);

  % define commands
  filter_cmd = [ ...
    'parms = get(gcbf, ''userdata'');' ...
    'tmp_filter = parms.filter;'...
    'parms.filter = get(findobj(gcbf, ''tag'', ''UI_filter''),''value'');'...
    'tmp_filter_notch = parms.filter_notch;'...
    'parms.filter_notch = get(findobj(gcbf, ''tag'', ''UI_filter_notch''),''value'');'...
    'tmp_filter_low_cf = str2num(get(findobj(gcbf, ''tag'', ''UI_filter_low_cf''),''string''));'...
    'tmp_filter_low_tb = str2num(get(findobj(gcbf, ''tag'', ''UI_filter_low_tb''),''string''));'...
    'tmp_filter_high_cf = str2num(get(findobj(gcbf, ''tag'', ''UI_filter_high_cf''),''string''));'...
    'tmp_filter_high_tb = str2num(get(findobj(gcbf, ''tag'', ''UI_filter_high_tb''),''string''));'...
    'tmp_filter_notch_cf = str2num(get(findobj(gcbf, ''tag'', ''UI_filter_notch_cf''),''string''));'...
    'tmp_filter_notch_tb = str2num(get(findobj(gcbf, ''tag'', ''UI_filter_notch_tb''),''string''));'...
    'if size(tmp_filter_low_cf)~=1 | tmp_filter_low_cf <0'...
    '  set(findobj(gcbf, ''tag'', ''UI_filter_low_cf''),''string'',num2str(parms.filter_low_cf));'...
    'else'...
    '  parms.filter_low_cf = tmp_filter_low_cf;'...
    'end;'...
    'if size(tmp_filter_low_tb)~=1 | tmp_filter_low_tb <0'...
    '  set(findobj(gcbf, ''tag'', ''UI_filter_low_tb''),''string'',num2str(parms.filter_low_tb));'...
    'else'...
    '  parms.filter_low_tb = tmp_filter_low_tb;'...
    'end;'...
    'if size(tmp_filter_high_cf)~=1 | tmp_filter_high_cf <0'...
    '  set(findobj(gcbf, ''tag'', ''UI_filter_high_cf''),''string'',num2str(parms.filter_high_cf));'...
    'else'...
    '  parms.filter_high_cf = tmp_filter_high_cf;'...
    'end;'...
    'if size(tmp_filter_high_tb)~=1 | tmp_filter_high_tb <0'...
    '  set(findobj(gcbf, ''tag'', ''UI_filter_high_tb''),''string'',num2str(parms.filter_high_tb));'...
    'else'...
    '  parms.filter_high_tb = tmp_filter_high_tb;'...
    'end;'...
    'if size(tmp_filter_notch_cf)~=1 | tmp_filter_notch_cf <0'...
    '  set(findobj(gcbf, ''tag'', ''UI_filter_notch_cf''),''string'',num2str(parms.filter_notch_cf));'...
    'else'...
    '  parms.filter_notch_cf = tmp_filter_notch_cf;'...
    'end;'...
    'if size(tmp_filter_notch_tb)~=1 | tmp_filter_notch_tb <0'...
    '  set(findobj(gcbf, ''tag'', ''UI_filter_notch_tb''),''string'',num2str(parms.filter_notch_tb));'...
    'else'...
    '  parms.filter_notch_tb = tmp_filter_notch_tb;'...
    'end;'...
    'set(gcbf, ''userdata'', parms);' ...
    'if tmp_filter || parms.dsfact~=1'... % if filtered (or downsampled) before, read again
    '  ts_browseraw(''readfile'');'... % readfile does it all
    'elseif parms.filter'...
    '  ts_browseraw(''filterdata'');'... % don't read again if not already filtered
    '  ts_browseraw(''findartifacts'');'...
    'end;'...
    'if tmp_filter || parms.filter'...
    '  ts_browseraw(''updateevents'');'...
    '  ts_browseraw(''drawp'',0);'...
    'end;'...
    'clear tmp_filter tmp_filter_notch tmp_filter_low_cf tmp_filter_low_tb tmp_filter_high_cf tmp_filter_high_tb tmp_filter_notch_cf tmp_filter_notch_tb;'...
  ];

  % create uicontrols
  n=1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_filter_label',...
   'HorizontalAlignment', 'left',...
   'string','FFT Filter');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_filter',...
   'TooltipString','apply bandpass fft filter',...
   'HorizontalAlignment', 'left',...
   'callback', filter_cmd,...
   'value', parms.filter,...
   'string','Bandpass');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_filter_notch',...
   'TooltipString','apply notch fft filter',...
   'HorizontalAlignment', 'left',...
   'callback', filter_cmd,...
   'value', parms.filter_notch,...
   'string','Notch');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_filter_low_cf',...
   'TooltipString','low center frequency (Hz)',...
   'HorizontalAlignment', 'left',...
   'callback', filter_cmd,...
   'string',num2str(parms.filter_low_cf));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_filter_low_tb',...
   'TooltipString','low transition band (Hz)',...
   'HorizontalAlignment', 'left',...
   'callback', filter_cmd,...
   'string',num2str(parms.filter_low_tb));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_filter_high_cf',...
   'TooltipString','high center frequency (Hz)',...
   'HorizontalAlignment', 'left',...
   'callback', filter_cmd,...
   'string',num2str(parms.filter_high_cf));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_filter_high_tb',...
   'TooltipString','high transition band (Hz)',...
   'HorizontalAlignment', 'left',...
   'callback', filter_cmd,...
   'string',num2str(parms.filter_high_tb));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_filter_notch_cf',...
   'TooltipString','notch center frequency (Hz)',...
   'HorizontalAlignment', 'left',...
   'callback', filter_cmd,...
   'string',num2str(parms.filter_notch_cf));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_filter_notch_tb',...
   'TooltipString','notch transition band (Hz)',...
   'HorizontalAlignment', 'left',...
   'callback', filter_cmd,...
   'string',num2str(parms.filter_notch_tb));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_low_label',...
   'HorizontalAlignment', 'left',...
   'string','low');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_high_label',...
   'HorizontalAlignment', 'left',...
   'string','high');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_notch_label',...
   'HorizontalAlignment', 'left',...
   'string','notch');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_center_label',...
   'HorizontalAlignment', 'left',...
   'string','center');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_trans_label',...
   'HorizontalAlignment', 'left',...
   'string','transition');

  clear uipos u;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % value group
  ui_offset = ui_value;

  %% todo: adjust to prevent overlap -- esp. time

  % set positions
  n=1;
  uipos(n,:) = [ 0.07      0.0       0.1       0.039  ]; n=n+1; % chanel
  uipos(n,:) = [ 0.00      0.0       0.07      0.039  ]; n=n+1; % channel label
  uipos(n,:) = [ 0.19      0.0       0.25      0.039  ]; n=n+1; % time
  uipos(n,:) = [ 0.15      0.0       0.045     0.039  ]; n=n+1; % time label
  uipos(n,:) = [ 0.375     0.0       0.19      0.039  ]; n=n+1; % value
  uipos(n,:) = [ 0.32      0.0       0.055     0.039  ]; n=n+1; % value label
  uipos(1:n-1,1) = uipos(1:n-1,1) + ui_offset(1);
  uipos(1:n-1,2) = uipos(1:n-1,2) + ui_offset(2);

  % create uicontrols
  n=1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_chan',...
   'HorizontalAlignment', 'left',...
   'string',[]);
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_chan_label',...
   'HorizontalAlignment', 'left',...
   'string','Channel:');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_time',...
   'HorizontalAlignment', 'left',...
   'string',[]);
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_time_label',...
   'HorizontalAlignment', 'left',...
   'string','Time:');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_value',...
   'HorizontalAlignment', 'left',...
   'string',[]);
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_value_label',...
   'HorizontalAlignment', 'left',...
   'string','Value:');
  n=n+1;

  clear uipos u;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % spacing group
  ui_offset = ui_scaling;

  % set positions
  n=1;
  uipos(n,:) = [ 0.0       0.01      0.07      0.04   ]; n=n+1; % scaling
  uipos(n,:) = [ 0.08      0.03      0.03      0.0270 ]; n=n+1; % +
  uipos(n,:) = [ 0.08      0.0       0.03      0.0270 ]; n=n+1; % -
  uipos(n,:) = [ 0.01      0.055     0.10      0.031  ]; n=n+1; % scaling label
  uipos(1:n-1,1) = uipos(1:n-1,1) + ui_offset(1);
  uipos(1:n-1,2) = uipos(1:n-1,2) + ui_offset(2);

  % create uicontrols
  n=1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_scaling',...
   'TooltipString','vertical scaling in arbitrary units',...
   'string',num2str(parms.scaling),...
   'Callback', 'ts_browseraw(''draws'',0);' );
  n=n+1;
  % UI_scaling buttons: + -
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Tag','Pushbutton5',...
   'string','+',...
   'FontSize',8,...
   'Callback','ts_browseraw(''draws'',1)');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'Position',uipos(n,:), ...
   'Tag','Pushbutton6',...
   'string','-',...
   'FontSize',8,...
   'Callback','ts_browseraw(''draws'',2)');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_scaling_label',...
   'HorizontalAlignment', 'left',...
   'string','Scaling');

  clear uipos u;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % display group
  ui_offset = ui_display;

  % set positions
  n=1;
  uipos(n,:) = [ 0.00      0.20     0.12      0.031  ]; n=n+1; % winlength label
  uipos(n,:) = [ 0.12      0.20     0.04      0.039  ]; n=n+1; % winlength
  uipos(n,:) = [ 0.00      0.16     0.08      0.039  ]; n=n+1; % plot events
  uipos(n,:) = [ 0.08      0.16     0.08      0.039  ]; n=n+1; % display event durs
  uipos(n,:) = [ 0.00      0.12     0.08      0.039  ]; n=n+1; % xgrid
  uipos(n,:) = [ 0.08      0.12     0.08      0.039  ]; n=n+1; % ygrid
  uipos(n,:) = [ 0.00      0.08     0.16      0.039  ]; n=n+1; % showlabels
  uipos(n,:) = [ 0.00      0.04     0.16      0.039  ]; n=n+1; % submean
  uipos(n,:) = [ 0.00      0.00     0.12      0.033  ]; n=n+1; % dispchans label
  uipos(n,:) = [ 0.12      0.00     0.04      0.039  ]; n=n+1; % dispchans
  uipos(1:n-1,1) = uipos(1:n-1,1) + ui_offset(1);
  uipos(1:n-1,2) = uipos(1:n-1,2) + ui_offset(2);

  % define commands
  winlength_cmd = [...
    'parms = get(gcbf, ''userdata'');' ...
    'tmp_winlength = str2num(get(findobj(gcbf, ''tag'', ''UI_winlength''),''string''));'...
    'if size(tmp_winlength)==1 & tmp_winlength>0'...
    '  parms.winlength = round(max(1,min(tmp_winlength,parms.maxwinlength)));'...
    'end;'...
    'set(findobj(gcbf, ''tag'', ''UI_winlength''),''string'',num2str(parms.winlength));'...
    'set(gcbf, ''userdata'', parms);' ...
    'ts_browseraw(''drawp'',5);'...
    'clear tmp_winlength;'...
  ];
  plotevent_cmd = [...
    'parms = get(gcbf, ''userdata'');' ...
    'parms.plotevent = get(findobj(gcbf, ''tag'', ''UI_plotevent''),''value'');'...
    'parms.ploteventdur = get(findobj(gcbf, ''tag'', ''UI_ploteventdur''),''value'');'...
    'set(gcbf, ''userdata'', parms);' ...
    'ts_browseraw(''updateevents'');'...
    'ts_browseraw(''drawb'');'...
  ];
  xgrid_cmd = [...
    'parms = get(gcbf, ''userdata'');' ...
    'parms.xgrid = get(findobj(gcbf, ''tag'', ''UI_xgrid''),''value'');'...
    'set(gcbf, ''userdata'', parms);' ...
    'tmp_ax = findobj(''tag'',''UI_dataaxis'',''parent'',gcbf);',...
    'set(tmp_ax,''xgrid'',fastif(parms.xgrid,''on'',''off''));',...
    'clear tmp_ax;'...
  ];
  ygrid_cmd = [...
    'parms = get(gcbf, ''userdata'');' ...
    'parms.ygrid = get(findobj(gcbf, ''tag'', ''UI_ygrid''),''value'');'...
    'set(gcbf, ''userdata'', parms);' ...
    'tmp_ax = findobj(''tag'',''UI_dataaxis'',''parent'',gcbf);',...
    'set(tmp_ax,''ygrid'',fastif(parms.ygrid,''on'',''off''));',...
    'clear tmp_ax;'...
  ];
  showlabels_cmd = [...
    'parms = get(gcbf, ''userdata'');' ...
    'parms.showlabels = get(findobj(gcbf, ''tag'', ''UI_showlabels''),''value'');'...
    'set(gcbf, ''userdata'', parms);' ...
    'ts_browseraw(''setchanlabels'');'...
  ];
  submean_cmd = [...
    'parms = get(gcbf, ''userdata'');' ...
    'parms.submean = get(findobj(gcbf, ''tag'', ''UI_submean''),''value'');'...
    'set(gcbf, ''userdata'', parms);' ...
    'ts_browseraw(''drawp'',0);'...
  ];
  dispchans_cmd = [ ...
    'parms = get(gcbf, ''userdata'');' ...
    'tmp_dispchans = str2num(get(findobj(gcbf, ''tag'', ''UI_dispchans''),''string''));'...
    'if size(tmp_dispchans)==1 & tmp_dispchans>0'...
    '  parms.dispchans = round(tmp_dispchans);'...
    '  parms.actualdispchans = max(1,min(parms.dispchans,length(parms.readchans)));'...
    'end;'...
    'set(findobj(gcbf, ''tag'', ''UI_dispchans''),''string'',num2str(parms.dispchans));'...
    'set(gcbf, ''userdata'', parms);' ...
    'ts_browseraw(''updateslider'', gcbf);'...
    'ts_browseraw(''drawp'',0);'...
    'clear tmp_dispchans;'...
  ];

  % create uicontrols
  n=1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_winlength_label',...
   'HorizontalAlignment', 'left',...
   'string','Window Length');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_winlength',...
   'TooltipString','duration of data to read/display (secs)',...
   'HorizontalAlignment', 'left',...
   'callback', winlength_cmd,...
   'string',num2str(parms.winlength));
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_plotevent',...
   'TooltipString','plot lines marking events',...
   'HorizontalAlignment', 'left',...
   'callback', plotevent_cmd,...
   'value', parms.plotevent,...
   'string','events');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_ploteventdur',...
   'TooltipString','plot event durations',...
   'HorizontalAlignment', 'left',...
   'callback', plotevent_cmd,...
   'value', parms.ploteventdur,...
   'string','durs');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_xgrid',...
   'TooltipString','display x grid lines',...
   'HorizontalAlignment', 'left',...
   'callback', xgrid_cmd,...
   'value', parms.xgrid,...
   'string','x grid');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_ygrid',...
   'TooltipString','display y grid lines',...
   'HorizontalAlignment', 'left',...
   'callback', ygrid_cmd,...
   'value', parms.ygrid,...
   'string','y grid');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_submean',...
   'TooltipString','subtract mean from each channel',...
   'HorizontalAlignment', 'left',...
   'callback', submean_cmd,...
   'value', parms.submean,...
   'string','subtract mean');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','checkbox', ...
   'Tag','UI_showlabels',...
   'TooltipString','show channel labels (instead of numbers)',...
   'HorizontalAlignment', 'left',...
   'callback', showlabels_cmd,...
   'value', parms.showlabels,...
   'string','show chan labels');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_dispchans_label',...
   'HorizontalAlignment', 'left',...
   'string','disp # chans');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_dispchans',...
   'TooltipString','number of channels to display',...
   'HorizontalAlignment', 'left',...
   'callback', dispchans_cmd,...
   'string',num2str(parms.dispchans));
  n=n+1;

  clear uipos u;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % downsamp group
  ui_offset = ui_downsamp;

%% todo: add to display group
  % set positions
  n=1;
  uipos(n,:) = [ 0.00      0.04     0.12      0.033  ]; n=n+1; % dsfact label
  uipos(n,:) = [ 0.0       0.00     0.07      0.04   ]; n=n+1; % dsfact
  uipos(1:n-1,1) = uipos(1:n-1,1) + ui_offset(1);
  uipos(1:n-1,2) = uipos(1:n-1,2) + ui_offset(2);

  % define commands
  dsfact_cmd = [ ...
    'parms = get(gcbf, ''userdata'');' ...
    'tmp_dsfact = str2num(get(findobj(gcbf, ''tag'', ''UI_dsfact''),''string''));'...
    'if size(tmp_dsfact)==1 & tmp_dsfact>0'...
    '  parms.dsfact = round(tmp_dsfact);'...
    '  parms.sfreq = parms.hdr.sfreq/parms.dsfact;'...
    '  parms.frames = round(parms.winlength*parms.sfreq);'...
    '  parms.prestim_samp  = round(parms.prestim_dur  * parms.sfreq/1000);'...
    '  parms.poststim_samp = round(parms.poststim_dur * parms.sfreq/1000);'...
    'end;'...
    'set(findobj(gcbf, ''tag'', ''UI_dsfact''),''string'',num2str(parms.dsfact));'...
    'set(gcbf, ''userdata'', parms);' ...
    'ts_browseraw(''readfile'');'...
    'ts_browseraw(''updateevents'');'...
    'ts_browseraw(''drawp'',0);'...
    'clear tmp_dsfact;'...
  ];

  % create uicontrols
  n=1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_dsfact_label',...
   'HorizontalAlignment', 'left',...
   'string','Downsampling');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_dsfact',...
   'TooltipString','downsampling factor',...
   'callback', dsfact_cmd,...
   'string',num2str(parms.dsfact));
  n=n+1;

  clear uipos u;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % manual group
  ui_offset = ui_manual;

  % set positions
  n=1;
  uipos(n,:) = [ 0.00      0.20     0.13      0.031  ]; n=n+1; % manual label
  uipos(n,:) = [ 0.00      0.16     0.08      0.039  ]; n=n+1; % manual_reject
  uipos(n,:) = [ 0.00      0.12     0.08      0.039  ]; n=n+1; % manual_event1
  uipos(n,:) = [ 0.08      0.12     0.04      0.039  ]; n=n+1; % manual_event_code1
  uipos(n,:) = [ 0.00      0.08     0.08      0.039  ]; n=n+1; % manual_event2
  uipos(n,:) = [ 0.08      0.08     0.04      0.039  ]; n=n+1; % manual_event_code2
  uipos(n,:) = [ 0.00      0.04     0.08      0.039  ]; n=n+1; % manual_event3
  uipos(n,:) = [ 0.08      0.04     0.04      0.039  ]; n=n+1; % manual_event_code3
  uipos(1:n-1,1) = uipos(1:n-1,1) + ui_offset(1);
  uipos(1:n-1,2) = uipos(1:n-1,2) + ui_offset(2);

  % define commands
  manual_cmd = [...
    'parms = get(gcbf, ''userdata'');' ...
    'tmp_manual_event_code1 = str2num(get(findobj(gcbf, ''tag'', ''UI_manual_event_code1''),''string''));'...
    'if size(tmp_manual_event_code1)~=1 | tmp_manual_event_code1 <0'...
    '  set(findobj(gcbf, ''tag'', ''tmp_manual_event_code1''),''string'',''1'');'...
    'end;'...
    'tmp_manual_event_code2 = str2num(get(findobj(gcbf, ''tag'', ''UI_manual_event_code2''),''string''));'...
    'if size(tmp_manual_event_code2)~=1 | tmp_manual_event_code2 <0'...
    '  set(findobj(gcbf, ''tag'', ''tmp_manual_event_code2''),''string'',''2'');'...
    'end;'...
    'tmp_manual_event_code3 = str2num(get(findobj(gcbf, ''tag'', ''UI_manual_event_code3''),''string''));'...
    'if size(tmp_manual_event_code3)~=1 | tmp_manual_event_code3 <0'...
    '  set(findobj(gcbf, ''tag'', ''tmp_manual_event_code3''),''string'',''3'');'...
    'end;'...
    'tmp_UI = get(gcbo,''tag'');' ...
    'if strcmp(tmp_UI,''UI_manual_reject'')'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event1''),''value'',0);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event2''),''value'',0);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event3''),''value'',0);'...
    '  parms.manual_reject = 1;'...
    '  parms.manual_event  = 0;'...
    'elseif strcmp(tmp_UI,''UI_manual_event1'')'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_reject''),''value'',0);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event2''),''value'',0);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event3''),''value'',0);'...
    '  parms.manual_reject = 0;'...
    '  parms.manual_event  = 1;'...
    '  parms.manual_event_code = tmp_manual_event_code1;'...
    'elseif strcmp(tmp_UI,''UI_manual_event2'')'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_reject''),''value'',0);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event1''),''value'',0);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event3''),''value'',0);'...
    '  parms.manual_reject = 0;'...
    '  parms.manual_event  = 1;'...
    '  parms.manual_event_code = tmp_manual_event_code2;'...
    'elseif strcmp(tmp_UI,''UI_manual_event3'')'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_reject''),''value'',0);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event1''),''value'',0);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event2''),''value'',0);'...
    '  parms.manual_reject = 0;'...
    '  parms.manual_event  = 1;'...
    '  parms.manual_event_code = tmp_manual_event_code3;'...
    'elseif strcmp(tmp_UI,''UI_manual_event_code1'')'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_reject''),''value'',0);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event1''),''value'',1);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event2''),''value'',0);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event3''),''value'',0);'...
    '  parms.manual_reject = 0;'...
    '  parms.manual_event  = 1;'...
    '  parms.manual_event_code = tmp_manual_event_code1;'...
    'elseif strcmp(tmp_UI,''UI_manual_event_code2'')'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_reject''),''value'',0);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event1''),''value'',0);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event2''),''value'',1);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event3''),''value'',0);'...
    '  parms.manual_reject = 0;'...
    '  parms.manual_event  = 1;'...
    '  parms.manual_event_code = tmp_manual_event_code2;'...
    'elseif strcmp(tmp_UI,''UI_manual_event_code3'')'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_reject''),''value'',0);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event1''),''value'',0);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event2''),''value'',0);'...
    '  set(findobj(gcbf, ''tag'', ''UI_manual_event3''),''value'',1);'...
    '  parms.manual_reject = 0;'...
    '  parms.manual_event  = 1;'...
    '  parms.manual_event_code = tmp_manual_event_code3;'...
    'end;'...
    'parms.tmpevent.latency = 0;'...
    'parms.tmpevent.duration = 0;'...
    'set(gcbf, ''userdata'', parms);' ...
    'clear tmp_UI tmp_manual_event_code1 tmp_manual_event_code2 tmp_manual_event_code3;'...
  ];

  % create uicontrols
  n=1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','text', ...
   'Tag','UI_manual_label',...
   'HorizontalAlignment', 'left',...
   'string','Manual Marking');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','radiobutton', ...
   'Tag','UI_manual_reject',...
   'TooltipString','mouse clicks on data window create manual rejects',...
   'HorizontalAlignment', 'left',...
   'callback', manual_cmd,...
   'value', 1,...
   'string','reject');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','radiobutton', ...
   'Tag','UI_manual_event1',...
   'TooltipString','mouse clicks on data window create manual events',...
   'HorizontalAlignment', 'left',...
   'callback', manual_cmd,...
   'value', 0,...
   'string','event');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_manual_event_code1',...
   'TooltipString','event code for manual event 1',...
   'HorizontalAlignment', 'left',...
   'callback', manual_cmd,...
   'string','1');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','radiobutton', ...
   'Tag','UI_manual_event2',...
   'TooltipString','mouse clicks on data window create manual events',...
   'HorizontalAlignment', 'left',...
   'callback', manual_cmd,...
   'value', 0,...
   'string','event');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_manual_event_code2',...
   'TooltipString','event code for manual event 2',...
   'HorizontalAlignment', 'left',...
   'callback', manual_cmd,...
   'string','2');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',DEFAULT_FIG_COLOR, ...
   'Position',uipos(n,:), ...
   'Style','radiobutton', ...
   'Tag','UI_manual_event3',...
   'TooltipString','mouse clicks on data window create manual events',...
   'HorizontalAlignment', 'left',...
   'callback', manual_cmd,...
   'value', 0,...
   'string','event');
  n=n+1;
  u(n) = uicontrol('Parent',figh, ...
   'Units', 'normalized', ...
   'BackgroundColor',[1 1 1], ...
   'Position',uipos(n,:), ...
   'Style','edit', ...
   'Tag','UI_manual_event_code3',...
   'TooltipString','event code for manual event 3',...
   'HorizontalAlignment', 'left',...
   'callback', manual_cmd,...
   'string','3');
  n=n+1;

  clear uipos u;

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  set(figh, 'windowbuttondownfcn', 'ts_browseraw(''mouseclickdown'')');
  set(figh, 'windowbuttonmotionfcn', 'ts_browseraw(''mousemove'')');
  set(figh, 'interruptible', 'off');
  set(figh, 'busyaction', 'cancel');

  parms.commandselect = {'ts_browseraw(''mouseclickdown'')' 'ts_browseraw(''mousemove'')' ''};

  % make sure events have proper fields
  if ~isempty(parms.events)
    if ~isfield(parms.events, 'type') | ~isfield(parms.events, 'latency'), parms.events = []; end;
    if ~isfield(parms.events, 'duration') | ~isfield(parms.events, 'condition'), parms.events = []; end;
  end;

  % make sure event durations are numeric
  for ev=1:length(parms.events)
    if ~isnumeric(parms.events(ev).duration) | size(parms.events(ev).duration)~=1
      parms.events(ev).duration = 1;
    end;
    if parms.events(ev).duration==0
      parms.events(ev).duration = 1;
    end;
    if isempty(parms.events(ev).condition)
      parms.events(ev).condition = 0;
    end;
  end;
  
  %% todo: add support for numeric or string codes?
  % make sure event conditions are numeric
  for ev=1:length(parms.events)
    if ~isnumeric(parms.events(ev).condition) | size(parms.events(ev).condition)~=1
      parms.events(ev).condition = 0;
    end;
  end;
 
  set(figh, 'UserData', parms);
  ts_browseraw('readfile');
  ts_browseraw('initevents');
  ts_browseraw('updateevents');
  parms = get(figh,'UserData');

  hold(ax1,'on');

  % reset scaling and draw data
  UI_scaling = findobj('tag','UI_scaling','parent',figh);   % ui handle
  set(UI_scaling,'string',num2str(parms.scaling,4))  % update edit box
  ts_browseraw('draws',0);
  if parms.actualdispchans ~= parms.chans
    ts_browseraw('zoom', gcf);
  end;

  h = findobj(gcf, 'style', 'pushbutton');
  set(h, 'backgroundcolor', BUTTON_COLOR);
  h = findobj(gcf, 'tag', 'UI_slider');
  set(h, 'backgroundcolor', BUTTON_COLOR);
  set(figh, 'visible', 'on');
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% end main function
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
else
  try, p1 = varargin{1}; p2 = varargin{2}; p3 = varargin{3}; catch, end;
  switch datafile
  case 'drawp' % draw data and change position
    % this test help to couple ts_browseraw windows
    if exist('p3')
        figh = p3;
        figure(p3);
    else    
        figh = gcf;                          % figure handle
    end;
    
    if strcmp(get(figh,'tag'),'dialog')
      figh = get(figh,'UserData');
    end
    ax0 = findobj('tag','UI_backaxis','parent',figh); % axes handle
    ax1 = findobj('tag','UI_dataaxis','parent',figh); % axes handle
    parms = get(figh,'UserData');
    data = get(ax1,'UserData');
    
    UI_scaling = findobj('tag','UI_scaling','parent',figh);   % ui handle
    UI_position = findobj('tag','UI_position','parent',figh); % ui handle
    tmp_scaling = str2num(get(UI_scaling,'string'));
    if size(tmp_scaling)==1 & tmp_scaling>=0
      parms.scaling = tmp_scaling;
      if parms.scaling ~= 0
        parms.spacing = 1000/parms.scaling;
      else
        parms.spacing = 0;
      end;
    end;
    set(findobj('tag','UI_scaling','parent',figh), 'string', num2str(parms.scaling));

    newtime = str2num(get(UI_position,'string'));
    if(newtime ~= parms.rawbegtime)
      if(newtime < 0)
        parms.rawbegtime = 0;
      else
        parms.rawbegtime = newtime;
      end
      parms.rawendtime = parms.rawbegtime + parms.winlength;
      newtime = 1;
    else
      newtime = 0;
    end
    if p1 == 1
      parms.rawbegtime = parms.rawbegtime - parms.winlength;
      parms.rawendtime = parms.rawbegtime + parms.winlength;
      newtime = 1;
    elseif p1 == 2               
      % < subtract one second or 1/5 of winlength
      parms.rawbegtime=parms.rawbegtime-fastif(parms.winlength>=1, 1, parms.winlength/5);
      parms.rawendtime=parms.rawbegtime+parms.winlength;
      newtime = 1;
    elseif p1 == 3
      % > add one second or 1/5 of winlength
      parms.rawbegtime=parms.rawbegtime+fastif(parms.winlength>=1, 1, parms.winlength/5);
      parms.rawendtime=parms.rawbegtime+parms.winlength;
      newtime = 1;
    elseif p1 == 4
      parms.rawbegtime = parms.rawbegtime + parms.winlength;
      parms.rawendtime = parms.rawbegtime + parms.winlength;
      newtime = 1;
    elseif p1 == 5
      parms.rawbegtime = parms.rawbegtime;
      parms.rawendtime = parms.rawbegtime + parms.winlength;
      newtime = 1;
    end
    
    %% make sure we don't reverse to negative
    if(parms.rawbegtime<0)
      parms.rawbegtime = 0;
      parms.rawendtime = parms.rawbegtime + parms.winlength;
      newtime = 1;
    end
    
    % make sure we don't advance past tlast (if tlast is known)
    if(parms.hdr.tlast>0)
      if(parms.rawbegtime>parms.hdr.tlast)
        parms.rawbegtime = parms.hdr.tlast;
        parms.rawendtime = parms.rawbegtime + parms.winlength;
        newtime = 1;
      end
    end

    if(newtime)
      set(figh, 'UserData', parms);
      ts_browseraw('clearrejects');
      ts_browseraw('readfile');
      ts_browseraw('updateevents');
      parms = get(figh,'UserData');
      data = get(ax1,'UserData');
      [parms.chans,parms.frames] = size(data);
    end

    if parms.report_progress
      fprintf('\n%s: drawing data: ',mfilename); tic;
    end;

    % Update edit box
    % ---------------
    set(UI_position,'string',num2str(parms.rawbegtime)); 
    set(figh, 'userdata', parms);

    % calculate mean for each channel
    if(parms.submean)
      meandata = ts_nan_mean(data');
    else
      meandata = zeros(1,parms.chans);
    end;

    if parms.spacing == 0
      maxindex = min(10000, parms.frames);  
      parms.spacing = 0.1*max(max(data(:,1:maxindex),[],2),[],1)-min(min(data(:,1:maxindex),[],2),[],1);  % Set parms.spacing to max/min data
    end;
    if parms.spacing == 0
      parms.spacing = 100;
    end;
    parms.scaling = 1000/parms.spacing;

    % plot data (but don't actually draw yet)
    % ---------
    cla(ax1);
    hold(ax1,'on');
    for i = 1:parms.chans
      plot(ax1,data(parms.chans-i+1,:)-meandata(parms.chans-i+1)+i*parms.spacing, ...
        'color', parms.color{mod(i-1,length(parms.color))+1}, 'clipping','on')
    end
    set(ax1, 'Xlim',[1 parms.winlength*parms.sfreq+1],...
             'XTick',[1:parms.sfreq*DEFAULT_GRID_SPACING:parms.winlength*parms.sfreq+1]);
    set(ax1, 'XTickLabel', num2str((parms.rawbegtime:DEFAULT_GRID_SPACING:parms.rawbegtime+parms.winlength)'))
    set(ax1, 'ylim',[parms.chanoffset*parms.spacing (parms.chanoffset+parms.actualdispchans+1)*parms.spacing]);
    ts_browseraw('drawb'); % will actually draw data

    if parms.children ~= 0
      if ~exist('p2')
        p2 =[];
      end;    
      ts_browseraw( 'drawp', p1, p2, parms.children);
      figure(figh);
    end;

    if parms.report_progress
      toc;
    end;
     
  case 'drawb' % Draw background ******************************************************
    % Redraw data and change position
    ax0 = findobj('tag','UI_backaxis','parent',gcf); % axes handle
    ax1 = findobj('tag','UI_dataaxis','parent',gcf); % axes handle
    parms = get(gcf,'UserData');

    % draw background axis now and set as current axis for drawing events
    axes(ax0);
    cla;
    hold on;

    % draw events if any
    % ------------------
    tmp_event_ticks = [];
    tmp_event_labels = [];
    if parms.plotevent
      lowlim = round(parms.rawbegtime*parms.hdr.sfreq+1);
      highlim = round(parms.rawendtime*parms.hdr.sfreq+1);

      % find events to plot
      % ------------------
      parms.eventlatencies  = cell2mat({parms.events.latency parms.tmpevent.latency})+1;
      parms.eventlatencyend = parms.eventlatencies + cell2mat({parms.events.duration parms.tmpevent.duration})+1;
      parms.eventconditions = cell2mat({parms.events.condition parms.tmpevent.condition});
      event2plot = find ( parms.eventlatencies >=lowlim & parms.eventlatencies <= highlim );
      if ~isempty(parms.eventlatencyend)            
          event2plot2 = find ( parms.eventlatencyend >= lowlim & parms.eventlatencyend <= highlim );
          event2plot3 = find ( parms.eventlatencies  <  lowlim & parms.eventlatencyend >  highlim );
          event2plot  = union(union(event2plot, event2plot2), event2plot3);
      end;

      for index = 1:length(event2plot)
        % draw latency line
        % -----------------
        tmplat = (parms.eventlatencies(event2plot(index))-lowlim-1)/parms.dsfact;
        tmpcond = parms.eventconditions(event2plot(index));
        tmph   = plot([tmplat tmplat], ylim, 'color', parms.eventcolors{event2plot(index)}, ...
                      'linestyle', parms.eventstyle {event2plot(index)}, ...
                      'linewidth', parms.eventwidths( event2plot(index) ) );

        if tmplat>0 & tmpcond>0
          % display event code numbers (condition) at top of plot for each event
          tmp_event_ticks(end+1) = tmplat;
          tmp_event_labels(end+1) = tmpcond;
        end;

        % draw duration is not 0
        % ----------------------
        if parms.ploteventdur & ~isempty(parms.eventlatencyend)
          tmplatend = (parms.eventlatencyend(event2plot(index))-lowlim-1)/parms.dsfact;
          if tmplatend ~= 0, 
            tmplim = ylim;
            tmpcol = parms.eventcolors{event2plot(index)};
            h = patch([ tmplat tmplatend tmplatend tmplat ], ...
                      [ tmplim(1) tmplim(1) tmplim(2) tmplim(2) ], ...
                      tmpcol );  % this argument is color
            set(h, 'EdgeColor', 'none') 
          end;
        end;
      end;
    end;

    % sort event tick labels
    if ~isempty(tmp_event_ticks)
      [tmp_event_ticks, indx] = sort(tmp_event_ticks);
      tmp_event_labels = tmp_event_labels(indx);
    end

    set(ax0,...
      'XTickLabel', tmp_event_labels,'YTickLabel', [],...
      'Xlim',[0 parms.winlength*parms.sfreq],...
      'XTick',tmp_event_ticks, 'YTick',[], 'tag','UI_backaxis');
    set(ax1,...
      'XTickLabel',num2str((parms.rawbegtime:DEFAULT_GRID_SPACING:parms.rawbegtime+parms.winlength)'),...
      'XTick',[1:parms.sfreq*DEFAULT_GRID_SPACING:parms.winlength*parms.sfreq+1])
    set(ax1,...
      'ylim',[parms.chanoffset*parms.spacing (parms.chanoffset+parms.actualdispchans+1)*parms.spacing]);

    axes(ax1); % actually draw data now
    return;

  case 'draws'
    % draw data and change scale
    ax1 = findobj('tag','UI_dataaxis','parent',gcf);         % axes handle
    parms = get(gcf,'UserData');  
    data = get(ax1, 'userdata');
    UI_scaling = findobj('tag','UI_scaling','parent',gcf);   % ui handle
    UI_position = findobj('tag','UI_position','parent',gcf); % ui handle
    tmp_scaling = str2num(get(UI_scaling,'string'));
    if size(tmp_scaling)==1 & tmp_scaling>=0
      parms.scaling = tmp_scaling;
    end;
    set(findobj('tag','UI_scaling','parent',gcf), 'string', num2str(parms.scaling));

    % +/- button presses
    orgscaling = parms.scaling;
    if p1 == 1
      parms.scaling = parms.scaling + 0.1*orgscaling; % increase parms.scaling (10%)
    elseif p1 == 2
      parms.scaling = max(0,parms.scaling - 0.1*orgscaling); % decrease parms.scaling (10%)
    end
    
    if parms.scaling ~= 0
      parms.spacing = 1000/parms.scaling;
    else
      parms.spacing = 0;
    end;
    
    % find optimal spacing if not already set
    if parms.spacing == 0
      maxindex = min(10000, parms.frames);
      parms.spacing = 0.1*max(max(data(:,1:maxindex),[],2),[],1)-min(min(data(:,1:maxindex),[],2),[],1);  % Set parms.spacing to max/min data
    end;
    if parms.spacing == 0
      parms.spacing = 100;
    end;
    parms.spacing = full(parms.spacing); % weirdly sparse when only one channel
    parms.scaling = 1000/parms.spacing;
    set(UI_scaling,'string',num2str(parms.scaling,4))  % update edit box
    set(gcf, 'userdata', parms);
    ts_browseraw('drawp', 0);
    set(ax1,'YLim',[0 (parms.chans+1)*parms.spacing],'YTick',[0:parms.spacing:parms.chans*parms.spacing])
    set(ax1,'ylim',[parms.chanoffset*parms.spacing (parms.chanoffset+parms.actualdispchans+1)*parms.spacing] );
    return;

  case 'initevents'  % initialize events for plotting
    parms = get(gcf,'UserData');

    % create dummy events for autoreject, manual reject, and manual events
    %   so that they will be assigned colors that don't change
    parms.events(end+1).type = 'autoreject';
    parms.events(end  ).latency = 0;
    parms.events(end  ).condition = 0;
    parms.events(end  ).duration = 0;

    parms.events(end+1).type = 'reject';
    parms.events(end  ).latency = 0;
    parms.events(end  ).condition = 0;
    parms.events(end  ).duration = 0;

    parms.events(end+1).type = 'manual';
    parms.events(end  ).latency = 0;
    parms.events(end  ).condition = 0;
    parms.events(end  ).duration = 0;

    parms.tmpevent = parms.events(end); % tmp event will be used for marking events

    set(gcf, 'userdata', parms);
    return;

  case 'updateevents'  % initialize events for plotting
    parms = get(gcf,'UserData');

    if ~isempty(parms.events)
      if isstr(parms.events(1).type)
        [parms.eventtypes tmpind indexcolor] = unique({parms.events.type parms.tmpevent.type}); % indexcolor counting as the event type
      else
        [parms.eventtypes tmpind indexcolor] = unique(cell2mat({parms.events.type}));
      end;
      parms.eventcolors     = {'r', 'c', 'm', 'b', [0 0.8 0], 'g', [0 0.8 0]};  
      parms.eventstyle      = {'-' '-' '-'  '-'  '-' '-' '-' '--' '--' '--'  '--' '--' '--' '--'};
      parms.eventwidths     = [ 2 1 ];
      parms.eventtypecolors = parms.eventcolors(mod([1:length(parms.eventtypes)]-1 ,length(parms.eventcolors))+1);
      parms.eventcolors     = parms.eventcolors(mod(indexcolor-1               ,length(parms.eventcolors))+1);
      parms.eventtypestyle  = parms.eventstyle (mod([1:length(parms.eventtypes)]-1 ,length(parms.eventstyle))+1);
      parms.eventstyle      = parms.eventstyle (mod(indexcolor-1               ,length(parms.eventstyle))+1);
      indexwidth = ones(1,length(parms.eventtypes))*2;
      parms.eventtypewidths = parms.eventwidths (mod(indexwidth([1:length(parms.eventtypes)])-1 ,length(parms.eventwidths))+1);
      parms.eventwidths     = parms.eventwidths (mod(indexwidth(indexcolor)-1               ,length(parms.eventwidths))+1);
    end;
    if isempty(parms.events)
      parms.plotevent = 0;
    end;
    set(gcf, 'UserData', parms);
    return;
    
  case 'setchanlabels'
    parms = get(gcf,'UserData');
    AXH0 = findobj('tag','UI_dataaxis','parent',gcf);
    AXH1 = findobj('tag','UI_backaxis','parent',gcf);
    if parms.showlabels
      YLabels = parms.hdr.sensors.label(parms.readchans);
      YLabels = strvcat(YLabels);
      YLabels = flipud(str2mat(YLabels,' '));
      set(AXH0,'YTick',[0:parms.spacing:parms.chans*parms.spacing],...
               'YTickLabel',YLabels,'Position',LABELS_AXES_POSITION);
      set(AXH1,'Position',LABELS_AXES_POSITION);
    else
      YLabels = num2str(parms.readchans'); % use chan numbers by default
      YLabels = flipud(str2mat(YLabels,' '));
      set(AXH0,'YTick',[0:parms.spacing:parms.chans*parms.spacing],...
               'YTickLabel',YLabels,'Position',DEFAULT_AXES_POSITION);
      set(AXH1,'Position',DEFAULT_AXES_POSITION);
    end;    
    return;

  case 'zoom' % if zoom
    fig = varargin{1};
    ax1 = findobj('tag','UI_dataaxis','parent',fig); 
    ax2 = findobj('tag','UI_backaxis','parent',fig); 
    tmpxlim  = get(ax1, 'xlim');
    tmpylim  = get(ax1, 'ylim');
    tmpxlim2 = get(ax2, 'xlim');
    set(ax2, 'xlim', get(ax1, 'xlim'));
    parms = get(fig,'UserData');

    % deal with abscicia
    % ------------------
    Eposition = str2num(get(findobj('tag','UI_position','parent',fig), 'string'))-1;
    parms.winlength = (tmpxlim(2) - tmpxlim(1))/parms.sfreq;    
    Eposition = Eposition + (tmpxlim(1) - tmpxlim2(1)-1)/parms.sfreq;
    Eposition = round(Eposition*1000)/1000;
    set(findobj('tag','UI_position','parent',fig), 'string', num2str(Eposition+1));

    % deal with ordinate
    % ------------------
    parms.chanoffset = tmpylim(1)/parms.spacing;
    parms.actualdispchans  = round(1000*(tmpylim(2)-tmpylim(1))/parms.spacing)/1000;      

    set(fig,'UserData', parms);
    ts_browseraw('updateslider', fig);
    ts_browseraw('drawp', 0);

    % reactivate zoom if 3 arguments
    % ------------------------------
    if exist('p2') == 1
      zoom on;
      tmpstr = get(gcbf, 'windowbuttondownfcn');
      set(gcbf, 'windowbuttondownfcn', [ tmpstr '; ts_browseraw(''zoom'', gcbf, 1);' ]);
      set(gcbf, 'windowbuttonmotionfcn', parms.commandselect{2});
    end;

  case 'updateslider' % if zoom
    fig = varargin{1};
    parms = get(fig,'UserData');
    slider = findobj('tag','UI_slider','parent',fig);
    if parms.chanoffset < 0
      parms.chanoffset = 0;
    end;
    if parms.dispchans > parms.chans
      parms.actualdispchans = parms.chans;
    else
      parms.actualdispchans = parms.dispchans;
    end;
    if parms.actualdispchans >= parms.chans
      parms.actualdispchans = parms.chans;
      parms.chanoffset = 0;
      set(slider, 'visible', 'off');
    else
      set(slider, 'visible', 'on');         
      set(slider, 'value', parms.chanoffset/parms.chans, ...
                   'sliderstep', [1/(parms.chans-parms.actualdispchans) parms.actualdispchans/(parms.chans-parms.actualdispchans)]);
    end;
    if parms.chanoffset < 0
      parms.chanoffset = 0;
    end;
    if parms.chanoffset > parms.chans-parms.actualdispchans
      parms.chanoffset = parms.chans-parms.actualdispchans;
    end;
    set(fig,'UserData', parms);
   
  case 'drawlegend'
    fig = varargin{1};
    parms = get(fig,'UserData');

    if ~isempty(parms.events)
        nleg = length(parms.eventtypes);
        fig2 = figure('numbertitle', 'off', 'name', '', 'visible', 'off', 'menubar', 'none', 'color', DEFAULT_FIG_COLOR);
        pos = get(fig2, 'position');
        set(fig2, 'position', [ pos(1) pos(2) 130 10*nleg+20]);

        for index = 1:nleg
            plot([10 30], [(index-0.5) * 10 (index-0.5) * 10], 'color', parms.eventtypecolors{index}, 'linestyle', ...
                        parms.eventtypestyle{index}, 'linewidth', parms.eventtypewidths( index )); hold on;
            if iscell(parms.eventtypes)
                text(35, (index-0.5)*10, parms.eventtypes{index});
            else
                text(35, (index-0.5)*10, num2str(parms.eventtypes(index)));
            end;
        end;
        xlim([0 130]);
        ylim([0 nleg*10]);
        axis off;
        set(fig2, 'visible', 'on');
    end;

%% todo: take into account dsfact
  case 'clearmanual'
    parms = get(gcf,'UserData');
    lowlim = parms.rawbegtime*parms.hdr.sfreq+1;
    highlim = parms.rawendtime*parms.hdr.sfreq+1;
    if ~isempty(parms.events)
      manual = [find(strcmp('manual',{parms.events.type}))...;
                find(strcmp('reject',{parms.events.type}))];
      for i=1:length(manual)
        index = manual(i);
        t_start = parms.events(index).latency;
        t_end = t_start + parms.events(index).duration;
        if (((t_start > lowlim) && (t_start < highlim)) || ...
            ((t_end > lowlim) && (t_end < highlim)))
          parms.events(index).duration = 0;
        end;
      end;
      keep = find(cell2mat({parms.events.duration})~=0);
      parms.events = parms.events(keep);
    end;
    set(gcf,'UserData', parms);
    ts_browseraw('initevents');
    return;

  case 'clearrejects'
    parms = get(gcf,'UserData');
    if ~isempty(parms.events)
      % clear all autorejects
      autorejects = find(strcmp('autoreject',{parms.events.type}));
      if ~isempty(autorejects)
        others = setdiff(1:length(parms.events),autorejects);
        parms.events = parms.events(others);
      end;
    end;
    set(gcf,'UserData', parms);
    ts_browseraw('initevents');
    return;

 %% todo: do something about duplicate or overlapping events (e.g. rejects)?
 %        or different but simultaneous events?
  case 'sortevents'
    parms = get(gcbf,'UserData');
    if ~isempty(parms.events)
      [foo, indx] = sort([parms.events.latency]);
      parms.events = parms.events(indx);
    end
    set(gcbf,'UserData', parms);
    return;

  case 'findartifacts'
    parms = get(gcf,'UserData');
    if ~parms.autoreject || ~parms.plotevent, return; end;
    ts_browseraw('clearrejects');
    parms = get(gcf,'UserData');
    ax1 = findobj('tag','UI_dataaxis','parent',gcf); % axes handle

    % which channels are which type
    parms.mag_i = find(strcmp('mag',{parms.hdr.sensors.typestring{:}}));
    parms.grad_i = find(strncmp('grad',{parms.hdr.sensors.typestring{:}},4));
    parms.eeg_i = find(strcmp('eeg',{parms.hdr.sensors.typestring{:}}));
    parms.eog_i = find(strcmp('eog',{parms.hdr.sensors.typestring{:}}));
    parms.other_i = setdiff(1:parms.hdr.nChans,[parms.mag_i,parms.grad_i,parms.eeg_i,parms.eog_i]);

    reject_thresh(parms.mag_i)  = parms.reject_mag*parms.scale_mag;
    reject_thresh(parms.grad_i) = parms.reject_grad*parms.scale_grad;
    reject_thresh(parms.eeg_i)  = parms.reject_eeg*parms.scale_eeg;
    reject_thresh(parms.eog_i)  = parms.reject_eog*parms.scale_eog;
    reject_thresh(parms.other_i) = inf; % allow any value
    reject_thresh(find(reject_thresh<=0)) = inf;
    reject_thresh = reject_thresh(parms.readchans)';

    data = get(ax1,'UserData');
    [parms.chans,parms.frames]=size(data);

    % calculate mean for each channel
    if(parms.submean)
      meandata = ts_nan_mean(data');
    else
      meandata = zeros(1,parms.chans);
    end;

    time_mask = zeros(1,parms.frames);
    [reject_chans,reject_samples] = ...
      find(abs(data-meandata'*ones(size(time_mask)))>...
        reject_thresh*ones(size(time_mask)));
    %% todo: do something to let user know which channel caused rejection

    % expand rejected epochs with prestim_samp and poststim_samp
    time_mask(reject_samples) = 1;
    numsamples = length(time_mask);
    ind_nonzero =find(time_mask~=0);
    ind_onset   =find(abs(diff([-1 ind_nonzero]))>1);
    ind_offset  =find(abs(diff([ind_nonzero -1]))>1);
    last_offset=0;
    for i=1:length(ind_onset)
      onset = ind_nonzero(ind_onset(i));
      offset = ind_nonzero(ind_offset(i));
      onset = onset - parms.poststim_samp;
      offset = offset + parms.prestim_samp;
      if offset < last_offset, continue; end;
      if onset < 1, onset = 1; end;
      if offset > numsamples, offset = numsamples; end;
      time_mask(onset:offset)=1;
      if offset >= numsamples, break; end;
      last_offset = offset;
    end;

    % create autoreject events from reject_samples
    begsample = round(parms.rawbegtime*parms.hdr.sfreq + 1);
    if parms.dsfact>=1
      time_mask = interp(time_mask,parms.dsfact); % get time back to original sampling freq
    end;
    ind_nonzero =find(time_mask~=0);
    ind_onset   =find(abs(diff([-1 ind_nonzero]))>1);
    ind_offset  =find(abs(diff([ind_nonzero -1]))>1);
    for i=1:length(ind_onset)
      onset = ind_nonzero(ind_onset(i));
      offset = ind_nonzero(ind_offset(i));
      parms.events(end+1).type = 'autoreject';
      parms.events(end  ).latency = begsample + onset;
      parms.events(end  ).condition = 0;
      parms.events(end  ).duration = offset - onset + 1;
    end;

    set(gcf,'UserData', parms);
    return;

  case 'scaledata'
    parms = get(gcf,'UserData');
    ax1 = findobj('tag','UI_dataaxis','parent',gcf); % axes handle
    data = get(ax1,'UserData');

    % generate scale factors for each channel
    scale_facts = ones(parms.hdr.nChans,1);
    scale_facts(parms.mag_i) = PRESCALE_MAG*parms.scale_mag;
    scale_facts(parms.grad1_i) = PRESCALE_GRAD*parms.scale_grad;
    scale_facts(parms.grad2_i) = PRESCALE_GRAD*parms.scale_grad;
    scale_facts(parms.eeg_i) = PRESCALE_EEG*parms.scale_eeg;
    scale_facts(parms.eog_i) = PRESCALE_EOG*parms.scale_eog;

    data = diag(sparse(scale_facts(parms.readchans)))*data;

    set(gcf, 'UserData', parms);
    set(ax1, 'UserData', data);
    return;

  case 'filterdata'
    parms = get(gcf,'UserData');
    if ~(parms.filter || parms.filter_notch), return; end;
    ax1 = findobj('tag','UI_dataaxis','parent',gcf); % axes handle
    data = get(ax1,'UserData');

    if parms.filter_low_cf > parms.filter_high_cf
      temp = parms.filter_high_cf;
      parms.filter_high_cf = parms.filter_low_cf;
      parms.filter_low_cf  = parms.filter_high_cf;
      temp = parms.filter_high_tb;
      parms.filter_high_tb = parms.filter_low_tb;
      parms.filter_low_tb  = parms.filter_high_tb;
    end
    if parms.filter_high_tb < 0, parms.filter_high_tb=0; end;
    if parms.filter_low_tb < 0, parms.filter_low_tb=0; end;
    if parms.filter_notch_tb < 0, parms.filter_notch_tb=0; end;
    % detrend before filtering no matter what
    tmp_data = data';
    tmp_data = detrend(tmp_data);
    if parms.filter && parms.filter_notch
      data = ts_freq_filt(tmp_data,parms.hdr.sfreq,...
        [parms.filter_low_cf,parms.filter_high_cf,parms.filter_notch_cf],...
        [parms.filter_low_tb,parms.filter_high_tb,parms.filter_notch_tb],...
        'bandpassnotch')';
    elseif parms.filter
      data = ts_freq_filt(tmp_data,parms.hdr.sfreq,...
        [parms.filter_low_cf,parms.filter_high_cf],...
        [parms.filter_low_tb,parms.filter_high_tb],'bandpass')';
    elseif parms.filter_notch
      data = ts_freq_filt(tmp_data,parms.hdr.sfreq,...
        parms.filter_notch_cf,parms.filter_notch_tb,...
        'notch')';
    end;
    if isempty(data)
      fprintf('%s: error filtering data\n',mfilename);
      return;
    end;
    set(gcf, 'UserData', parms);
    set(ax1, 'UserData', data);
    return;

  case 'downsampdata'
    parms = get(gcf,'UserData');
    if parms.dsfact<=1, return; end;
    ax1 = findobj('tag','UI_dataaxis','parent',gcf); % axes handle
    data = get(ax1,'UserData');
    data = downsample(data',parms.dsfact)';
    set(gcf, 'UserData', parms);
    set(ax1, 'UserData', data);
    return;

  case 'setreadchans'
    parms = get(gcf,'UserData');

    if parms.minchan < 1, parms.minchan = 1; end;
    if parms.maxchan < 1 || parms.maxchan > parms.hdr.nChans, parms.maxchan = parms.hdr.nChans; end;
    if parms.minchan > parms.maxchan, parms.minchan = parms.maxchan; end;
    parms.readchans = [parms.minchan:parms.maxchan];
    parms.readchans = parms.readchans(~ismember(parms.readchans,parms.badchans));

    % which channels are which type
    parms.mag_i = find(strcmp('mag',{parms.hdr.sensors.typestring{:}}));
    parms.grad_i = find(strncmp('grad',{parms.hdr.sensors.typestring{:}},4));
    parms.grad1_i = find(strcmp('grad1',{parms.hdr.sensors.typestring{:}}));
    parms.grad2_i = find(strcmp('grad2',{parms.hdr.sensors.typestring{:}}));
    parms.eeg_i = find(strcmp('eeg',{parms.hdr.sensors.typestring{:}}));
    parms.eog_i = find(strcmp('eog',{parms.hdr.sensors.typestring{:}}));
    parms.other_i = setdiff(parms.readchans,[parms.mag_i,parms.grad1_i,parms.grad2_i,parms.eeg_i,parms.eog_i]);

    % exclude certain channel types from parms.rawchans
    if ~parms.read_mag
      parms.mag_i = [];
    end;
    if ~parms.read_grad1
      parms.grad1_i = [];  
    end;
    if ~parms.read_grad2
      parms.grad2_i = [];
    end;
    if ~parms.read_eeg
      parms.eeg_i = [];
    end;
    if ~parms.read_eog
      parms.eog_i = [];
    end;
    if ~parms.read_other
      parms.other_i = [];
    end;
    parms.readchans = intersect(parms.readchans,...
      [parms.mag_i parms.grad1_i parms.grad2_i parms.eeg_i parms.eog_i parms.other_i]);
    parms.chans = length(parms.readchans);
    if parms.dispchans==0, parms.dispchans = parms.chans; end;
    parms.actualdispchans = min(parms.dispchans,parms.chans);

    set(gcf, 'UserData', parms);
    return;

  case 'mouseclickdown'
    seltype = get(gcbf,'SelectionType');
    ax1 = findobj('tag','UI_backaxis','parent',gcbf);
    tmppos = get(ax1, 'currentpoint');
    parms = get(gcbf,'UserData');
    cursamp = round(tmppos(1)*parms.dsfact + parms.rawbegtime*parms.hdr.sfreq + 1);
    if (strcmp(seltype,'normal')) % left mouse click
      if cursamp > parms.rawbegtime*parms.hdr.sfreq &&...
         cursamp < parms.rawendtime*parms.hdr.sfreq
        if parms.manual_reject
          parms.tmpevent.type = 'reject';
          parms.tmpevent.latency = cursamp-1;
          parms.tmpevent.condition = 0;
          parms.tmpevent.duration = 1;
        elseif parms.manual_event
          parms.tmpevent.type = 'manual';
          parms.tmpevent.latency = cursamp-1;
          parms.tmpevent.condition = parms.manual_event_code;
          parms.tmpevent.duration = 1;
        end;
      else % if out of window range, no event
        parms.tmpevent.latency = 0;
        parms.tmpevent.duration = 0;
      end;
      set(gcbf,'UserData', parms);
      ts_browseraw('updateevents');
      ts_browseraw('drawb'); % redraw event lines
    elseif (strcmp(seltype,'alt'))  % right mouse click
      if parms.tmpevent.latency ~= 0
        if (cursamp < parms.rawbegtime*parms.hdr.sfreq)
          cursamp = parms.rawbegtime*parms.hdr.sfreq + 1;
        elseif (cursamp > parms.rawendtime*parms.hdr.sfreq)
          cursamp = parms.rawendtime*parms.hdr.sfreq;
        end;
        parms.tmpevent.duration = max(1,abs(cursamp-1-parms.tmpevent.latency));
        if (parms.tmpevent.latency > cursamp-1)
          parms.tmpevent.latency = cursamp-1;
        end;
        parms.events(end+1) = parms.tmpevent;
        parms.tmpevent.latency = 0;
        parms.tmpevent.duration = 0;
        set(gcbf,'UserData', parms);
        ts_browseraw('updateevents');
        ts_browseraw('drawb'); % redraw event lines
      end;
    end;
    return;

  case 'mousemove'
  % mousemove: display time, channel, value for cursor position
    ax1 = findobj('tag','UI_backaxis','parent',gcbf);
    tmppos = get(ax1, 'currentpoint');
    parms = get(gcbf,'UserData');
    if isstruct(parms)      %check if we are dealing with the right window
      hh = findobj('tag','UI_time','parent',gcbf);
      tmptime = parms.rawbegtime + (tmppos(1))/parms.sfreq;
      if tmptime < parms.rawbegtime || tmptime > parms.rawendtime
        set(hh, 'string', []);
        hh = findobj('tag','UI_chan','parent',gcbf);
        set(hh, 'string', []);
        hh = findobj('tag','UI_value','parent',gcbf);
        set(hh, 'string', []);
      else
        tmpstring = sprintf('%0.4f sec',tmptime);
        set(hh, 'string', tmpstring); % put time in the box
        ax1 = findobj('tag','UI_dataaxis','parent',gcbf); 
        tmppos = get(ax1, 'currentpoint');
        tmpchan = round(tmppos(1,2) / parms.spacing);
        tmpchan = min(max(double(tmpchan), 1),parms.chans);
        tmpchan_i = parms.chans+1-tmpchan;
        tmpchan_j = parms.readchans(tmpchan_i);
        tmptype = parms.hdr.sensors.typestring{tmpchan_j};
        if strcmp(tmptype,'mag')
          tmpscale = parms.scale_mag;
          tmpunits = 'fT';
        elseif strncmp(tmptype,'grad',4)
          tmpscale = parms.scale_grad;
          tmpunits = 'fT/cm';
        elseif strcmp(tmptype,'eeg')
          tmpscale = parms.scale_eeg;
          tmpunits = 'uV';
        elseif strcmp(tmptype,'eog')
          tmpscale = parms.scale_eog;
          tmpunits = 'uV';
        else
          tmpscale = 1;
          tmpunits = [];
        end;
        labls = get(ax1, 'YtickLabel');
        hh = findobj('tag','UI_chan','parent',gcbf);  % put channel in the box
        set(hh, 'string', labls(tmpchan+1,:));
        hh = findobj('tag','UI_value','parent',gcbf);
        eegplotdata = get(ax1, 'userdata');
        if ~isempty(eegplotdata)
          tmpval = eegplotdata(tmpchan_i, min(parms.frames,max(1,double(round(tmppos(1)+1)))))/tmpscale;
          if parms.submean
            tmpmean = mean(eegplotdata(tmpchan_i,:)/tmpscale);
            tmpval = tmpval - tmpmean;
          end;
          tmpstring = sprintf('%0.2f %s',tmpval,tmpunits);
          set(hh, 'string', tmpstring);  % put value in the box
        end;
      end;
    end;
    return;

  case 'readfile'
    parms = get(gcf,'UserData');
    if parms.report_progress
      fprintf('\n%s: reading data: ',mfilename); tic;
    end;
    ax1 = findobj('tag','UI_dataaxis','parent',gcf); % axes handle
%    fprintf('reading raw data from %s...\n',parms.datafile);
    begsample = round(parms.rawbegtime*parms.hdr.sfreq + 1);
    endsample = round(parms.rawendtime*parms.hdr.sfreq);

    if isempty(parms.readchans)
      set(ax1, 'UserData', zeros(parms.chans,parms.orig_frames));
      return;
    end;
    [data,eofstatus] = ...
      ts_read_fif_data(parms.datafile,parms.hdr,begsample,endsample,parms.readchans);
    if(eofstatus)
      if(parms.hdr.tlast<0)
        % if we get here, then we didn't read tlast at start and we 
        % encountered eof while trying to read next buffer
        % if we had jumped past eof, we would get core dump
        parms.hdr.nBuffs = floor(begsample/parms.hdr.nSamples) - 1;
        parms.hdr.tlast = begsample;
        % in future, don't read past this point
      end
    end
    if parms.report_progress
      toc;
    end;
    
    set(gcf, 'UserData', parms);
    set(ax1, 'UserData', data);

    % scale each channel
    ts_browseraw('scaledata');

    if parms.filter
      if parms.report_progress
        fprintf('\n%s: filtering data: ',mfilename); tic;
      end;
      % apply bandpass filter
      ts_browseraw('filterdata');
      if parms.report_progress
        toc;
      end;
    end;
 
    if parms.dsfact~=1
      % downsample data
      ts_browseraw('downsampdata');
    end;

    % find artifacts
    ts_browseraw('findartifacts');

    return;

  otherwise
    error(['Error - invalid ts_browseraw() parameter: ',data])
  end  

end


