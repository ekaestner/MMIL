function MMIL_Process_Exam(ContainerPath,varargin)
%function MMIL_Process_Exam(ContainerPath,[options])
%
% Required Input:
%  ContainerPath:  full path of input Container (orig, raw, or proc)
%
% Optional Parameters that specify study specific information
%  'RootDirs':
%    a struct which must contain the following fields:
%         proc, fsurf
%    and may contain the following fields:
%         orig, raw, proc
%         fsurf, fsico, fsclean, long
%    these specify the locations of data
%  'ProjID': project name
%     Required if STRUCT_rawQCflag=1
%     {default = []}
%
% Optional Dicom Parameters
%  'DCM_linkflag': [0|1] whether to create links instead of copying from
%     orig to raw
%     {default = 1}
%  'DCM_RejectSeries': vector of dicom series indices to reject
%     {default = []}
%  'DCM_classify_file': full path name of csv file with rules
%     for classifying series of dicoms
%     {default = []}
%
% Optional Structural Parameters
%  'STRUCTflag': [0|1] whether to process structural data
%    {default = 1}
%  'STRUCT_VisitID': [0|1] Specify structural visit ID for registration of
%    BOLD and DTI data    If empty, will use the VisitID
%    {default = []}
%  'STRUCT_T1type': which type of T1 series ('MPR' or 'hiFA') to use as reference
%     i.e. which one gets registered to atlas and to which other scans are registered
%     0=MPR; 1=hiFA; 2=Either (prefer MPR); 3=Either (prefer hiFA)
%     {default=2}
%  'STRUCT_gradunwarp_flag': [0|1|2] whether to correct for gradient warping
%     if 2, processing is aborted if gradwarp info is missing
%     {default = 1}
%  'STRUCT_wmbc_flag': [0|1] whether to correct for intensity bias-field
%     using white matter segmentation and sparse smoothing
%    {default = 0}
%  'STRUCT_nu_flag': [0|1] whether to correct for intensity bias-field 
%     using nu (N3) correction
%     {default = 0}
%  'STRUCT_tal_flag': [0|1] register to Talairach space
%    for standardization of white matter intensity values
%    during nu correction
%    {default = 0}
%  'STRUCT_atlasflag': [0|1] whether to resample output in atlas space
%    (rigid-body registration only)
%    {default = 1}
%  'STRUCT_nativeflag': [0|1] if STRUCT_atlasflag=0
%     whether to keep native resolution
%     otherwise, resample to 1mm, 256^3, LIA
%     {default = 0}
%  'STRUCT_rawQCflag': [0|1] whether to use manual raw QC info
%    {default = 0}
%  'STRUCT_minmax': vector of minimum and maximum number of scans required
%    {default = [1 Inf]}
%  'STRUCT_scantypes': cell array of scan types to register
%     {default = {'MPR','XetaT2','FLASHhi','FLASHlo','MEDIChi','MEDIClo'}}
%  'STRUCT_BEMflag': [0|1] whether to generate BEM surfaces
%    {default = 0}
%  'STRUCT_first_flag': [0|1] whether to run FSL's FIRST
%     to generate hippocampal volumes
%     NOTE: requires FreeSurfer recon already exists
%    {default = 0}
%  'STRUCT_oldreg_flag': [0|1] use old registration mriRegister
%     otherwise use mmil_reg in mmil_average_volumes
%     {default = 0}
%  'STRUCT_prereg_flag': [0|1] whether to use reg for rigid registration
%     before running dct registration to atlas
%     {default = 1}  
%  'STRUCT_atlasdir': full path of atlas directory
%     {default =  [getenv('MMPS_DIR') '/atlases']}}
%  'STRUCT_atlasname': name of atlas file (omit .mat extension)
%     full path or relative to atlasdir
%     {default =  'T1_Atlas/T1_atlas'}
%
% Optional DTI Parameters
%  'DTIflag': [0|1] whether to process DTI data
%    {default = 0}
%  'DTI_snums': list of DTI scan numbers to use
%     if empty (or unspecified), use all DTI scans in container
%     {default = []}
%  'DTI_B0unwarp_flag': [0|1] whether to correct for B0 distortions
%    if 2, processing aborted if B0 unwarping fails (e.g. no rev scans)
%    {default = 1}
%  'DTI_motion_B0uw_flag': [0|1] whether to estimate head motion
%     and apply to B0dx field
%     {default = 0}
%  'DTI_ecc_flag': [0|1] whether to perform eddy current correction
%     {default=1}
%  'DTI_censor_flag': [0|1] reject bad slices based on tensor fit
%    {default=1}
%  'DTI_mc_flag': [0|1] whether to perform motion correction
%     {default=1}
%  'DTI_gradunwarp_flag': [0|1|2] whether to correct for gradient warping
%     if 2, processing is aborted if gradwarp info is missing
%    {default = 1}
%  'DTI_resample_flag': [0|1] whether to resample processed diffusion data
%     e.g. to make isotropic, to correct inter-scan motion, to register to T1
%    {default = 1}
%  'DTI_regT1flag': [0,1,2] whether to register DTI data to T1
%    0=do not register, 1=register only, 2=apply registration to diffusion data
%    {default = 1}
%  'DTI_export_flag': [0|1|2] export processed diffusion data 
%      0: do not export
%      1: in export_type format
%      2: with customized steps for FSL
%      {default = 0}
%  'DTI_CSD_tracto_flag': [0|1] run CSD tractography on processed diffusion data
%    {default = 0}
%  'DTI_calcDT_flag': [0|1] whether to perform diffusion tensor calculations
%    {default = 1}
%  'DTI_calcRSI_flag': [0|1] whether to perform Restriction Spectrum Imaging
%    calculations on processed diffusion data
%    {default = 0}
%  'DTI_ATLflag': [0|1] whether to use DTI_AtlasTrack to segment fibers
%    {default = 0}
%  'DTI_ATL_regFA_flag': [0|1] use FA image for dct morph for AtlasTrack
%    {default = 0}
%  'DTI_revflag': [0|1|2] specify whether to use non-rev or rev data
%     if revflag=0, use non-rev data
%     if revflag=1, use rev data
%       rev scans have names like 'DTI1_rev.mgz'
%     if revflag=2, use concatenated non-rev and rev data
%     {default = 0}
%  'DTI_min_ndirs': minimum number of gradient directions allowed
%    for tensor calculations
%    {default = 6}
%  'DTI_min_bval': minimum b-value allowed for tensor calculations
%    {default = 0}
%  'DTI_max_bval': maximum b-value used for tensor calculations
%    {default = Inf}
%  'DTI_flex_flag': [0|1] DTI_flex scans included in tensor fit
%    {default = 0}
%  'DTI_min_nb0': minimum number of b=0 images required for tensor calculations
%    Note: some scans (e.g. 1-dir diffusion) do have a b=0 image but the
%      report 0 b=0 images in the dicom header
%    {default = 1}
%  'DTI_censor_min_ndirs': minimum number of diffusion directions (not including
%    b=0 images) required for tensor fit after censoring
%    will not do censoring if remaining ndirs < min_ndirs
%    {default = 12}
%  'DTI_censor_thresh': error threshold for censoring bad frames
%    normalized to median error for each slice; higher values mean less censoring
%    {default = 3.2}
%  'DTI_optimize_B0uw_flag': [0|1] search for optimal B0 unwarp parameters
%     kernelWidthMax and lambda2
%    {default = 0}
%  'DTI_driftcorr': [0|1] estimate drift correction with eddy current correction
%     {default = 0}
%  'DTI_motion_B0uw_iters': number of iterations to estimate motion
%     and B0 displacement
%    {default = 2}
%  'DTI_min_trans': minimum translation (mm) for estimating motion
%    {default = 0.05}
%  'DTI_min_rot': minimum rotation (degrees) for estimating motion
%    {default = 0.05}
%  'DTI_nvoxels': vector of number of resampled voxels [nx,ny,nz]
%    {default = [120 120 70]}
%  'DTI_resolution': desired voxel sizes of resampled data (x y z)
%    {default = [2 2 2]}
%  'DTI_std_orient' : specify the resampled output orientation 
%    {default = []}  
%  'DTI_smooth': 3D isotropic full width half max blurring kernel (mm) applied
%     to processed diffusion data before tensor calculations
%    {default = 0}
%  'DTI_rot': rotation applied to processed diffusion data (x,y,z deg)
%    {default = [0,0,0]}
%  'DTI_trans': translation applied to processed diffusion data (x,y,z mm)
%    {default = [0,0,0]}
%  'DTI_bbregflag': [0|1] whether to register DTI to T1 using
%     FreeSurfer's bbregister
%    {default = 0}
%  'DTI_nii_out_orient': output orientation for nii format
%    {default = []}
%  'DTI_nob0_flag': [0|1] exclude b=0 images from tensor fitting
%     if 1, multiple b-values are required
%       also, b=0 images are still used for between image scaling
%    {default = 0}
%  'DTI_mask_DTmeas_flag': whether or not to mask DTmeas output volumes
%     {default = 1}
%  'DTI_DT_regT1flag': [0|1|2] whether to resample DT output
%    0=not resampled, 1=registered T1, 2=resampled T1
%    {default = 0}
%  'DTI_DT_nonlin_flag': [0|1] use nonlinear optimization for tensor fit
%     with initial parameters from linear fit
%     {default = 0}
%  'DTI_mask_RSImeas_flag': whether or not to mask RSImeas output volumes
%     {default = 1}
%  'DTI_RSI_regT1flag': [0|1|2] whether to resample RSI output
%    0=not resampled, 1=registered T1, 2=resampled T1
%    {default = 0}
%  'DTI_datflag': [0|1] whether to convert DTI FA and V0 to dat format
%    {default = 0}
%  'DTI_niiflag': [0|1] whether to convert DTI measures to nii format
%    {default = 0}
%  'DTI_outfix': string added to DTI file name after correction
%    {default = 'corr'}
%  'DTI_deoblique_flag': [0|1] whether to resample oblique slices to on-axis
%     ignored if native_flag = 1
%    {default = 1}
%  'DTI_fibers': fiber numbers to generate
%    ignored if DTI_ATLflag = 0
%     {default = [101:110,115:123,133:138,141:150]}
%  'DTI_subdiv_fibers': vector of fiber subdivision numbers
%    ignored if DTI_ATLflag = 0
%     {default = [1014,1024,1231,1232]}
%  'DTI_divide_fibers_flag': [0|1] divide fibers into subdivisions
%    ignored if DTI_ATLflag = 0
%     {default = 1}
%  'DTI_combine_fibers_flag': [0|1] combine fibers (e.g. left and right hemi)
%    ignored if DTI_ATLflag = 0
%     {default = 1}
%  'DTI_locflag': [0|1] use location information only for AtlasTrack
%    ignored if DTI_ATLflag = 0
%    {default = 0}
%  'DTI_xcg_flag': [0|1] exclude CSF and gray-mattter from fiber ROIs
%    ignored if DTI_ATLflag = 0
%    {default = 0}
%  'DTI_xcg_suffix': file name string included for CSF/gray excluded
%     ignored if DTI_ATLflag = 0 or DTI_xcg_flag = 0
%     {default = 'xcg'}
%  'DTI_xcg_codes': FreeSurfer aseg codes used to define xcg mask
%     ignored if DTI_ATLflag = 0 or DTI_xcg_flag = 0
%     {default = [0,24,4,5,14,15,43,44,72,75,76,3,8,42,47,31,63]}
%  'DTI_masksf_flag': [0|1] voxels with multiple fibers excluded
%    ignored if DTI_ATLflag = 0
%    {default = 0}
%  'DTI_masksf_suffix': file name string included for multiple fibers excluded
%     ignored if DTI_ATLflag = 0 or DTI_masksf_flag = 0
%     {default = 'masksf'}
%  'DTI_fseg_flag': [0|1] create fiber segmentation volume
%    ignored if DTI_ATLflag = 0
%    {default = 1}
%  'DTI_fiber_resT1flag': [0|1] resample AtlasTrack fibers to T1 resolution
%    {default=0}
%  'DTI_fiber_atlasdir': full path containing DTI fiber atlas files
%    ignored if DTI_ATLflag = 0
%    {default = [getenv('MMPS_DIR') '/atlases/DTI_Atlas/AllSubjects']}
%  'DTI_fiber_atlasname': name of the atlas fibers to be used
%    is not empty, output directory names will include this
%    ignored if DTI_ATLflag = 0
%    {default=[]} 
%
% Optional BOLD Parameters
%  'BOLDflag': [0|1] whether to process BOLD data
%    {default = 0}
%  'BOLD_snums': list of BOLD scan numbers to process
%    if empty (or unspecified), use all BOLD scans in container
%    {default = []}
%  'BOLD_outfix': string attached to BOLD file names after correction
%    {default = 'corr'}
%  'BOLD_B0unwarp_flag': [0|1] whether to correct for B0 distortions
%    if 2, processing aborted if B0 unwarping fails (e.g. no rev scans)
%    {default = 1}
%  'BOLD_optimize_B0uw_flag': [0|1] search for optimal B0 unwarp parameters
%    kernelWidthMax and lambda2
%    {default = 0}
%  'BOLD_regref_B0uw_flag': [0|1] whether to register reference image (fname_ref)
%     to fname_for (if revflag = 0) or fname_rev (if revflag = 1)
%     and apply transformation to B0dx
%    {default = 1}
%  'BOLD_motion_B0uw_flag': [0|1] whether to estimate head motion
%    and apply to B0dx field
%    {default = 0}
%  'BOLD_motion_B0uw_iters': number of iterations to estimate motion
%     and B0 displacement
%     {default = 2}
%  'BOLD_tshift_flag': [0|1] whether to correct for differences in
%    slice timing using AFNI's 3dTshift
%    {default = 1}
%  'BOLD_mc_flag': [0|1] whether to correct for motion using
%    AFNI's 3dvolreg
%    {default = 1}
%  'BOLD_gradunwarp_flag': [0|1|2] whether to correct for gradient distortions
%     if 2, processing is aborted if gradwarp info is missing
%    {default = 1}
%  'BOLD_regT1flag': [0,1,2] whether to register BOLD data to T1
%    0=do not register, 1=register only, 2=apply registration to BOLD data
%    {default = 1}
%  'BOLD_bbregflag': [0|1] whether to register BOLD to T1 using
%    FreeSurfer's bbregister
%    {default = 0}
%  'BOLD_tpattern': slice time pattern
%    Allowed values: {'alt+z', 'alt+z2', 'alt-z', 'alt-z2', 'seq+z', 'seq-z'}
%    {default = 'alt+z'}
%  'BOLD_skipTRs': number of TRs at beginning of scan to be ignored in time shifting
%    {default = 0}
%  'BOLD_resample_flag': [0|1] whether to resample processed BOLD data
%     e.g. to make isotropic, to correct inter-scan motion, to register to T1
%     {default = 1}
%  'BOLD_native_flag': resample but keep original nvoxels and resolution
%     {default = 0}
%  'BOLD_nvoxels': vector of number of resampled voxels [nx,ny,nz]
%    ignored if BOLD_native_flag = 1
%    {default = [120 120 70]}
%  'BOLD_resolution': desired voxel sizes of resampled data (x y z)
%    ignored if BOLD_native_flag = 1
%    {default = [2 2 2]}
%  'BOLD_deoblique_flag': [0|1] whether to resample oblique slices to on-axis
%    ignored if BOLD_native_flag = 1
%    {default = 1}
%  'BOLD_rot': rotation applied to processed BOLD data (x,y,z deg)
%     {default = [0,0,0]}
%  'BOLD_trans': translation applied to processed BOLD data (x,y,z mm)
%     {default = [0,0,0]}
%  'BOLD_smooth': 3D isotropic full width half max blurring kernel (mm) applied
%     to processed BOLD data
%     {default = 0}
%  'BOLD_export_flag': [0|1|2] export processed BOLD data as nii format
%    with value of 2, use customized steps to prepare for use with FSL
%    {default = 0}
%  'BOLD_export_smooth': blurring kernel FWHM applied to exported data
%    Only applies if export_flag = 2
%    {default = 5}
%  'BOLD_export_type': 'BRIK', 'nii', 'mgh', 'mgz'
%    {default = 'nii'}
%  'BOLD_nii_out_orient': output orientation for nii format
%     used if BOLD_export_flag = 1
%    {default = []}
%  'BOLD_extract_tseries_flag': [0|1] crate csv file containing averages
%     time series for aseg and aparc ROIs for each BOLD scan
%    {default = 0}
%
%  'unpackflag': [0|1] unpack dicoms from orig to raw only
%    {default = 0}
%  'preprocflag': [0|1] convert raw dicoms to mgz and stop
%    {default = 0}
%  'forceflag': [0|1] whether to overwrite existing output
%    {default = 0}
%
% Created:  10/15/09 by Don Hagler
% Prev Mod: 11/06/17 by Feng Xue
% Last Mod: 11/06/17 by Don Hagler
%

%% todo: reorder options, especially DTI
%%    remove documentation for less important ones?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if ~mmil_check_nargs(nargin,1), return; end;

parms = check_input(ContainerPath,varargin);

if parms.procstep==0 % start from orig
  % unpack dicom files
  [parms,errcode] = unpack_orig(parms);
  fprintf('%s: unpacking complete\n',mfilename);
  write_progress_file(parms,'unpacking',errcode);
  if errcode ~= 0
    write_progress_file(parms,'preprocessing',errcode);
    return;
  end;
end;

if parms.unpackflag
  fprintf('%s: stopping now (unpackflag = 1)\n',mfilename);
  return;
end;

if parms.procstep==1 % start from MRIRAW
  % convert dicom files
  [parms,errcode] = convert_raw(parms);
  fprintf('%s: preprocessing complete\n',mfilename);
  write_progress_file(parms,'preprocessing',errcode);
  if errcode ~= 0, return; end;
end;

if parms.preprocflag
  fprintf('%s: stopping now (preprocflag = 1)\n',mfilename);
  return;
end;

if parms.procstep==2 % start from MRIPROC
  if parms.STRUCTflag && ~isfield(parms,'STRUCT_errcode'), parms.STRUCT_errcode = 0; end;
  if parms.DTIflag && ~isfield(parms,'DTI_errcode'), parms.DTI_errcode = 0; end;
  if parms.BOLDflag && ~isfield(parms,'BOLD_errcode'), parms.BOLD_errcode = 0; end;
  % apply corrections, register images
  parms = preprocess_data(parms);
  % additional processing
  parms = postprocess_data(parms);
end;

fprintf('%s: processing complete\n',mfilename);
write_progress_file(parms,'processing');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function parms = check_input(ContainerPath,options)
  parms_filter = {...
    'RootDir',pwd,[],...
    'RootDirs',[],[],...
    'ProjID',[],[],...
  ...
    'DCM_linkflag',true,[false true],...
    'DCM_RejectSeries',[],[],...
    'DCM_classify_file',[],[],...
  ...
    'STRUCTflag',true,[false true],...
    'STRUCT_VisitID',[],[],...
    'STRUCT_T1type',2,[0:3],...
    'STRUCT_gradunwarp_flag',1,[0:2],...
    'STRUCT_wmbc_flag',false,[false true],...
    'STRUCT_nu_flag',false,[false true],...
    'STRUCT_tal_flag',false,[false true],...
    'STRUCT_atlasflag',true,[false true],...
    'STRUCT_nativeflag',false,[false true],...
    'STRUCT_rawQCflag',false,[false true],...
    'STRUCT_minmax',[1 inf],[],...
    'STRUCT_scantypes',{'MPR','XetaT2','FLASHhi','FLASHlo','MEDIChi','MEDIClo'},[],...
    'STRUCT_BEMflag',false,[false true],...
    'STRUCT_first_flag',false,[false true],...
    'STRUCT_first_nu_flag',true,[false true],...
    'STRUCT_oldreg_flag',false,[false true],...
    'STRUCT_prereg_flag',true,[false true],...  
    'STRUCT_atlasdir',[],[],...
    'STRUCT_atlasname','T1_Atlas/T1_atlas',[],... 
  ...
    'DTIflag',false,[false true],...
    'DTI_snums',[],[],...
    'DTI_B0unwarp_flag',1,[0:2],...
    'DTI_motion_B0uw_flag',false,[false true],...
    'DTI_ecc_flag',true,[false true],...
    'DTI_censor_flag',true,[false,true],...
    'DTI_mc_flag',true,[false true],...
    'DTI_gradunwarp_flag',1,[0:2],...
    'DTI_resample_flag',true,[false true],...
    'DTI_regT1flag',1,[0 1 2],...
    'DTI_export_flag',0,[0 1 2],...
    'DTI_CSD_tracto_flag',false,[false true],...
    'DTI_calcDT_flag',true,[false true],...
    'DTI_calcRSI_flag',false,[false true],...
    'DTI_ATLflag',false,[false true],...
  ...
    'DTI_ATL_regFA_flag',false,[false true],...
    'DTI_revflag',0,[0 1 2],...
    'DTI_min_ndirs',6,[6,Inf],...
    'DTI_min_bval',1,[0,Inf],...
    'DTI_max_bval',Inf,[100,Inf],...
    'DTI_flex_flag',false,[false true],...
    'DTI_min_nb0',1,[0,Inf],...
    'DTI_censor_min_ndirs',12,[],...
    'DTI_censor_thresh',3.2,[],...
    'DTI_optimize_B0uw_flag',false,[false true],...
    'DTI_driftcorr',false,[false true],...
    'DTI_motion_B0uw_iters',2,[1:10],...
    'DTI_min_trans',0.05,[0,1],... % mm
    'DTI_min_rot',0.05,[0,1],... % degrees
    'DTI_nvoxels',[120 120 70],[10,1000],...
    'DTI_resolution',[2 2 2],[0.1,10],...
    'DTI_std_orient',[],[],...
    'DTI_smooth',0,[],...
    'DTI_rot',[0 0 0],[],...
    'DTI_trans',[0 0 0],[],...
    'DTI_bbregflag',false,[false true],...
    'DTI_nii_out_orient',[],[],...
    'DTI_nob0_flag',false,[false true],...
    'DTI_mask_DTmeas_flag',true,[false true],... 
    'DTI_DT_regT1flag',0,[0 1 2],...
    'DTI_DT_nonlin_flag',false,[false true],...
    'DTI_mask_RSImeas_flag',true,[false true],... 
    'DTI_RSI_regT1flag',0,[0 1 2],...
    'DTI_datflag',false,[false true],...
    'DTI_niiflag',false,[false true],...
    'DTI_outfix','corr',[],...
    'DTI_deoblique_flag',true,[false true],...
    'DTI_fibers',[101:110,115:123,133:138,141:150],[],...
    'DTI_subdiv_fibers',[1014,1024,1231,1232],[],...
    'DTI_divide_fibers_flag',true,[false true],...
    'DTI_combine_fibers_flag',true,[false true],...
    'DTI_locflag',false,[false true],...
    'DTI_xcg_flag',false,[false true],...
    'DTI_xcg_suffix','xcg',[],...
    'DTI_xcg_codes',[0,24,4,5,14,15,43,44,72,75,76,3,8,42,47,31,63],[],...
    'DTI_masksf_flag',false,[false true],...
    'DTI_masksf_suffix','masksf',[],...
    'DTI_fseg_flag',true,[false true],...
    'DTI_fseg_thresh_prob',[],[],...
    'DTI_fiber_resT1flag',[],[],...
    'DTI_fiber_atlasdir',[],[],...
    'DTI_fiber_atlasname',[],[],...
    'DTI_cleanupflag',true,[false true],...
  ...
    'DTI_CSD_seed_point_sampling',[2 2 2],[],...
    'DTI_CSD_step_size',1,[],...
    'DTI_CSD_FOD_thresh',0.1,[],...
    'DTI_CSD_angle_thresh',45,[],...
    'DTI_CSD_fiber_length_range',[50 500],[],...
    'DTI_CSD_max_order',4,[2:2:100],...
    'DTI_CSD_FA_thresh',0.8,[0 1],...
  ...
    'DTI_DT_outdir','DTcalc',[],...
    'DTI_DT_outfix',[],[],...
  ...
    'DTI_RSI_outdir','RSIcalc',[],...
    'DTI_RSI_outfix',[],[],...
    'DTI_RSI_lambda',0.1,[],...
    'DTI_RSI_iso_free_flag',true,[false true],...
    'DTI_RSI_iso_hindered_flag',true,[false true],...
    'DTI_RSI_iso_restricted_flag',true,[false true],...
    'DTI_RSI_ADC_free',3e-3,[],...
    'DTI_RSI_ADC_hindered',1.5e-3,[],...
    'DTI_RSI_ADC_long',1e-3,[],...
    'DTI_RSI_ADC_trans_min',0,[],...
    'DTI_RSI_ADC_trans_max',0.9e-3,[],...
    'DTI_RSI_num_ADC_trans',5,[],...
    'DTI_RSI_SH_order',4,[2:2:10],...
    'DTI_RSI_norm_flag',false,[false true],...
  ...
    'BOLDflag',false,[false true],...
    'BOLD_snums',[],[],...
    'BOLD_outfix','corr',[],...
    'BOLD_B0unwarp_flag',1,[0:2],...
    'BOLD_optimize_B0uw_flag',false,[false true],...
    'BOLD_regref_B0uw_flag',true,[false true],...
    'BOLD_motion_B0uw_flag',false,[false true],...
    'BOLD_motion_B0uw_iters',2,[1:10],...
    'BOLD_tshift_flag',true,[false true],...
    'BOLD_mc_flag',true,[false true],...
    'BOLD_gradunwarp_flag',1,[0:2],...
    'BOLD_regT1flag',1,[0 1 2],...
    'BOLD_bbregflag',false,[false true],...
    'BOLD_tpattern','alt+z',{'alt+z', 'alt+z2', 'alt-z', 'alt-z2', 'seq+z', 'seq-z'},...
    'BOLD_skipTRs',0,[0,Inf],...
    'BOLD_resample_flag',true,[false true],...
    'BOLD_native_flag',false,[false true],...
    'BOLD_nvoxels',[120 120 70],[10,1000],...
    'BOLD_resolution',[2 2 2],[0.1,10],...
    'BOLD_deoblique_flag',true,[false true],...
    'BOLD_rot',[0 0 0],[],...
    'BOLD_trans',[0 0 0],[],...
    'BOLD_smooth',0,[],...
    'BOLD_export_flag',0,[0:2],...
    'BOLD_export_smooth',5,[0,100],...
    'BOLD_export_type','nii',{'nii','BRIK','mgh','mgz'},...
    'BOLD_nii_out_orient',[],[],...
    'BOLD_extract_tseries_flag',false,[false true],...
  ...
    'BOLD_min_trans',0.05,[0,1],... % mm
    'BOLD_min_rot',0.05,[0,1],... % degrees
    'BOLD_cleanupflag',true,[false true],...
  ...
    'unpackflag',false,[false true],...
    'preprocflag',false,[false true],...
    'forceflag',false,[false true],...
  ... % B0uw optimization
    'kernelWidthMax',25,[1:100],...
    'lambda2',1100,[1:10000],...
    'kernelWidthMax_vec',[25,31,35],[1:100],...
    'lambda2_vec',[1100,1500,1900],[1:10000],...
    'multi_opt_flag',false,[false true],...
  };
  parms = mmil_args2parms(options,parms_filter);
  if isempty(parms.RootDirs)
    if mmil_isrelative(parms.RootDir)
      parms.RootDir = [pwd '/' parms.RootDir];
    end;
    parms.RootDirs = MMIL_Set_Common_RootDirs(parms.RootDir);
  end;
  required_rootdirs = {'raw','proc'};
  if parms.BOLDflag
    required_rootdirs{end+1} = 'proc_bold';
  end;
  if parms.DTIflag
    required_rootdirs{end+1} = 'proc_dti';
  end;
  if (parms.DTIflag && parms.DTI_bbregflag) ||...
     (parms.BOLDflag && parms.BOLD_bbregflag)
    required_rootdirs{end+1} = 'fsurf';
  end;
  parms.RootDirs = MMIL_Check_RootDirs(parms.RootDirs,required_rootdirs);

  parms.Containers = [];
  parms.ContPaths = [];

  % determine container type, VisitID, and processing step
  parms = check_container(ContainerPath,parms);
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function parms = check_container(ContainerPath,parms)
  [ContainerRootDir,ContainerDir,tmp_ext] = fileparts(ContainerPath);
  if isempty(ContainerRootDir)
    ContainerRootDir = pwd;
  elseif mmil_isrelative(ContainerRootDir)
    ContainerRootDir = [pwd '/' ContainerRootDir];
  end;
  ContainerDir = [ContainerDir tmp_ext];
  regpat = '^(?<ContainerType>[^_]+)_(?<VisitID>[\w-+^]+)_(?<StudyDate>\d{8})\..+';
  n = regexp(ContainerDir,regpat,'names');
  parms.procstep = 0;
  ContainerType = [];
  if ~isempty(n)
    ContainerType = n(1).ContainerType;    
    parms.VisitID = n.VisitID;
    switch ContainerType
      case 'MRIRAW'
        parms.procstep = 1;
        parms.Containers.raw = ContainerDir;
        parms.RootDirs.raw = ContainerRootDir;
        parms.ContPaths.raw = [parms.RootDirs.raw '/' parms.Containers.raw];
      case 'MRIPROC'
        parms.procstep = 2;
        parms.Containers.proc = ContainerDir;
        parms.RootDirs.proc = ContainerRootDir;
        parms.ContPaths.proc = [parms.RootDirs.proc '/' parms.Containers.proc];
        parms.DTIflag = 0;
        parms.BOLDflag = 0;
      case 'DTIPROC'
        parms.procstep = 2;
        parms.Containers.proc_dti = ContainerDir;
        parms.RootDirs.proc_dti = ContainerRootDir;
        parms.ContPaths.proc_dti = ...
          [parms.RootDirs.proc_dti '/' parms.Containers.proc_dti];
        parms.STRUCTflag = 0;
        parms.BOLDflag = 0;
      case 'BOLDPROC'
        parms.procstep = 2;
        parms.Containers.proc_bold = ContainerDir;
        parms.RootDirs.proc_bold = ContainerRootDir;
        parms.ContPaths.proc_bold = ...
          [parms.RootDirs.proc_bold '/' parms.Containers.proc_bold];
        parms.STRUCTflag = 0;
        parms.DTIflag = 0;
      case 'FSURF'
        error('FSURF container not supported');
      case {'PETRAW','PETPROC'}
        error('PET containers not supported');
      otherwise
        ContainerType = [];
    end;
  else
    ContainerType = 'orig';
    % replace any '.' in VisitID with '_' (avoids problems with job names)
    parms.VisitID = regexprep(ContainerDir,'\.','_');
    parms.Containers.orig = ContainerDir;
    parms.RootDirs.orig = ContainerRootDir;
    parms.ContPaths.orig = [parms.RootDirs.orig '/' parms.Containers.orig];
  end;
  if isempty(parms.STRUCT_VisitID)
    parms.STRUCT_VisitID = parms.VisitID;
  end;
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [parms,errcode] = unpack_orig(parms)
  errcode = 0;
  % if it exists, input scan parameters from manually inputed csv
  fname_info = sprintf('%s/tmpSeriesInfo.csv',parms.ContPaths.orig);
  if exist(fname_info,'file')
    % for non DICOM's: copy files and create raw ContainerInfo from tmpSeriesInfo.csv
    [parms.Containers.raw,errcode] = MMIL_Unpack_NonDicoms(...
      parms.RootDirs.orig,parms.Containers.orig,...
      parms.RootDirs.raw,parms.VisitID,fname_info,parms.forceflag);
  else
    [parms.Containers.raw,errcode] = MMIL_Unpack_Dicoms(...
      parms.RootDirs.orig,parms.Containers.orig,...
      parms.RootDirs.raw,parms.VisitID,parms.DCM_linkflag,parms.forceflag);
  end;
  if errcode ~= 0, return; end;  
  % add ProjID and MMPSVER to ContainerInfo
  parms.ContPaths.raw = [parms.RootDirs.raw '/' parms.Containers.raw];
  [errcode,warncode] = ...
    MMIL_Stamp_Container(parms.ContPaths.raw,parms.ProjID);
  parms.procstep = 1;
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% todo: add conversion_completed tag to ContainerInfo
%%       skip conversion if complete

function [parms,errcode] = convert_raw(parms)
  errcode = 0;
  parms.STRUCT_errcode = 0;
  parms.DTI_errcode = 0;
  parms.BOLD_errcode = 0;
  [ContainerInfo,errcode] = MMIL_Load_ContainerInfo(parms.ContPaths.raw);
  if errcode ~= 0, return; end;
  if isfield(ContainerInfo,'nondicom_flag') && ContainerInfo.nondicom_flag==1
    parms.DTIflag = 0; % note: DTI and BOLD not supported for nondicom
    parms.BOLDflag = 0;
    % convert MRI data from non-dicoms to mgh/mgz
    [parms.Containers.proc,parms.STRUCT_errcode] =...
      MMIL_Convert_NonDicom_MRIRAW_to_MRIPROC(...
        parms.RootDirs.raw,parms.Containers.raw,...
        parms.RootDirs.proc,parms.forceflag);
    if parms.STRUCT_errcode == 0
      % add ProjID and MMPSVER to ContainerInfo
      parms.ContPaths.proc = [parms.RootDirs.proc '/' parms.Containers.proc];
      [parms.STRUCT_errcode,warncode] = ...
        MMIL_Stamp_Container(parms.ContPaths.proc,parms.ProjID);
    end;
    if parms.STRUCT_errcode == 0, parms.procstep = 2; end;
  else
    % classify series from dicom header information
    errcode = MMIL_Classify_Dicoms(parms.ContPaths.raw,...
      parms.DCM_RejectSeries,parms.DCM_classify_file,parms.forceflag);
    if errcode ~= 0 return; end;

    % convert MRI data from dicoms to mgh/mgz
    if parms.STRUCTflag
      [parms.Containers.proc,parms.STRUCT_errcode] = ...
        MMIL_Convert_MRIRAW_to_MRIPROC(...
          parms.RootDirs.raw,parms.Containers.raw,...
          parms.RootDirs.proc,parms.forceflag);
      if parms.STRUCT_errcode==0
        % add ProjID and MMPSVER to ContainerInfo
        parms.ContPaths.proc = [parms.RootDirs.proc '/' parms.Containers.proc];
        [parms.STRUCT_errcode,warncode] = ...
          MMIL_Stamp_Container(parms.ContPaths.proc,parms.ProjID);
      end;
      if parms.STRUCT_errcode == 0, parms.procstep = 2; end;
    end;

    % convert DTI data from dicoms to mgh/mgz
    if parms.DTIflag
      [parms.Containers.proc_dti,parms.DTI_errcode] = ...
        MMIL_Convert_MRIRAW_to_DTIPROC(...
          parms.RootDirs.raw,parms.Containers.raw,...
          parms.RootDirs.proc_dti,parms.forceflag);
      if parms.DTI_errcode == 0
        % add ProjID and MMPSVER to ContainerInfo
        parms.ContPaths.proc_dti = ...
          [parms.RootDirs.proc_dti '/' parms.Containers.proc_dti];
        [parms.DTI_errcode,warncode] = ...
          MMIL_Stamp_Container(parms.ContPaths.proc_dti,parms.ProjID);
      end;
      if parms.DTI_errcode == 0, parms.procstep = 2; end;
    end;

    % convert BOLD data from dicoms to mgh/mgz
    if parms.BOLDflag
      [parms.Containers.proc_bold,parms.BOLD_errcode] = ...
        MMIL_Convert_MRIRAW_to_BOLDPROC(...
          parms.RootDirs.raw,parms.Containers.raw,...
          parms.RootDirs.proc_bold,parms.forceflag);
      if parms.BOLD_errcode == 0
        % add ProjID and MMPSVER to ContainerInfo
        parms.ContPaths.proc_bold = ...
          [parms.RootDirs.proc_bold '/' parms.Containers.proc_bold];
        [parms.BOLD_errcode,warncode] = ...
          MMIL_Stamp_Container(parms.ContPaths.proc_bold,parms.ProjID);
      end;
      if parms.BOLD_errcode == 0, parms.procstep = 2; end;
    end;
  end;

  if parms.STRUCT_errcode && parms.DTI_errcode && parms.BOLD_errcode
    errcode = 1;
  end;
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function parms = preprocess_data(parms)
  if parms.STRUCTflag, parms = process_structurals(parms); end;
  parms = check_T1(parms);
  if parms.DTIflag, parms = process_DTI(parms); end;
  if parms.BOLDflag, parms = process_BOLD(parms); end;
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function parms = process_structurals(parms)
  if parms.STRUCT_errcode, return; end;
  parms.STRUCT_errcode = MMIL_Process_Structurals(parms.ContPaths.proc,...
    'refT1flag',parms.STRUCT_T1type,...
    'gradunwarp_flag',parms.STRUCT_gradunwarp_flag,...
    'wmbc_flag',parms.STRUCT_wmbc_flag,...
    'nu_flag',parms.STRUCT_nu_flag,...
    'tal_flag',parms.STRUCT_tal_flag,...
    'atlasflag',parms.STRUCT_atlasflag,...
    'nativeflag',parms.STRUCT_nativeflag,...
    'rawQCflag',parms.STRUCT_rawQCflag,...
    'ProjID',parms.ProjID,...
    'minmax',parms.STRUCT_minmax,...
    'scantypes',parms.STRUCT_scantypes,...
    'oldreg_flag',parms.STRUCT_oldreg_flag,...
    'prereg_flag',parms.STRUCT_prereg_flag,...
    'atlasdir',parms.STRUCT_atlasdir,...
    'atlasname',parms.STRUCT_atlasname,...
    'forceflag',parms.forceflag);
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function parms = check_T1(parms)
  if ~isempty(parms.STRUCT_VisitID)
    parms.ContPaths.T1 = ...
      MMIL_Get_Container(parms.RootDirs,parms.STRUCT_VisitID,'proc');
    if isempty(parms.ContPaths.T1)
      fprintf('%s: WARNING: no Container found with STRUCT_VisitID %s\n',mfilename,parms.STRUCT_VisitID);
      if parms.BOLDflag || parms.DTIflag
        fprintf('%s: WARNING: disabling registration to T1\n',mfilename);
        if parms.DTI_regT1flag==2
          fprintf('%s: WARNING: disabling DTI resampling\n',mfilename);
          parms.DTI_resample_flag = 0;
        end;
        if parms.BOLD_regT1flag==2
          fprintf('%s: WARNING: disabling BOLD resampling\n',mfilename);
          parms.BOLD_resample_flag = 0;
        end;      
        parms.BOLD_regT1flag = 0;
        parms.DTI_regT1flag = 0;
      end;
    end;
  else
    parms.ContPaths.T1 = mmil_getfield(parms.ContPaths,'proc',[]);
  end;
  if ~isempty(parms.ContPaths.T1)
    [tmp,parms.Containers.T1,tmp_ext] = fileparts(parms.ContPaths.T1);
    parms.Containers.T1 = [parms.Containers.T1 tmp_ext];
    if isfield(parms.RootDirs,'fsurf')
      parms.ContPaths.fsurf = [parms.RootDirs.fsurf '/'...
        regexprep(parms.Containers.T1,'MRIPROC','FSURF')];
      if ~exist(parms.ContPaths.fsurf)
        parms.ContPaths.fsurf = [];
      end;
    else
      parms.ContPaths.fsurf = [];
    end;
  else
    parms.Containers.T1 = [];
    parms.ContPaths.fsurf = [];
  end;
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function parms = process_DTI(parms)
  if parms.DTI_errcode, return; end;
  if parms.DTI_bbregflag && isempty(parms.ContPaths.fsurf)
    fprintf('%s: WARNING: DTI_bbregflag=1 and FSContainerPath not found\n',...
      mfilename);
  end;
  [parms.DTI_infix,parms.DTI_errcode] = MMIL_Process_DTI(...
    parms.ContPaths.proc_dti,...
    'T1ContainerPath',parms.ContPaths.T1,...
    'FSContainerPath',parms.ContPaths.fsurf,...
    'outfix',parms.DTI_outfix,...
    'B0unwarp_flag',parms.DTI_B0unwarp_flag,...
    'motion_B0uw_flag',parms.DTI_motion_B0uw_flag,...
    'ecc_flag',parms.DTI_ecc_flag,...
    'censor_flag',parms.DTI_censor_flag,...
    'mc_flag',parms.DTI_mc_flag,...
    'gradunwarp_flag',parms.DTI_gradunwarp_flag,...
    'resample_flag',parms.DTI_resample_flag,...
    'regT1flag',parms.DTI_regT1flag,...
    'revflag',parms.DTI_revflag,...
    'censor_thresh',parms.DTI_censor_thresh,...
    'censor_min_ndirs',parms.DTI_censor_min_ndirs,...
    'optimize_B0uw_flag',parms.DTI_optimize_B0uw_flag,...
    'driftcorr',parms.DTI_driftcorr,...
    'motion_B0uw_iters',parms.DTI_motion_B0uw_iters,...
    'min_trans',parms.DTI_min_trans,...
    'min_rot',parms.DTI_min_rot,...
    'kernelWidthMax',parms.kernelWidthMax,...
    'lambda2',parms.lambda2,...
    'kernelWidthMax_vec',parms.kernelWidthMax_vec,...
    'deoblique_flag',parms.DTI_deoblique_flag,...
    'lambda2_vec',parms.lambda2_vec,...
    'multi_opt_flag',parms.multi_opt_flag,...
    'nvoxels',parms.DTI_nvoxels,...
    'resolution',parms.DTI_resolution,...
    'std_orient',parms.DTI_std_orient,...
    'smooth',parms.DTI_smooth,...
    'rot',parms.DTI_rot,...
    'trans',parms.DTI_trans,...
    'T1type',parms.STRUCT_T1type,...
    'bbregflag',parms.DTI_bbregflag,...
    'atlasdir',parms.STRUCT_atlasdir,...
    'atlasname',parms.STRUCT_atlasname,...
    'cleanupflag',parms.DTI_cleanupflag,...
    'forceflag',parms.forceflag);
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function parms = process_BOLD(parms)
  if parms.BOLD_errcode, return; end;
  if isempty(parms.ContPaths.fsurf)
    if parms.BOLD_bbregflag
      fprintf('%s: WARNING: BOLD_bbregflag=1 and FSContainerPath not found',...
        mfilename,parms.ContPaths.fsurf);
    end;
  end;
  [parms.BOLD_infix,parms.BOLD_errcode] = MMIL_Process_BOLD(...
    parms.ContPaths.proc_bold,...
    'T1ContainerPath',parms.ContPaths.T1,...
    'FSContainerPath',parms.ContPaths.fsurf,...
    'snums',parms.BOLD_snums,...
    'outfix',parms.BOLD_outfix,...
    'B0unwarp_flag',parms.BOLD_B0unwarp_flag,...
    'optimize_B0uw_flag',parms.BOLD_optimize_B0uw_flag,...
    'kernelWidthMax',parms.kernelWidthMax,...
    'lambda2',parms.lambda2,...
    'kernelWidthMax_vec',parms.kernelWidthMax_vec,...
    'lambda2_vec',parms.lambda2_vec,...
    'multi_opt_flag',parms.multi_opt_flag,...
    'regref_B0uw_flag',parms.BOLD_regref_B0uw_flag,...
    'motion_B0uw_flag',parms.BOLD_motion_B0uw_flag,...
    'motion_B0uw_iters',parms.BOLD_motion_B0uw_iters,...
    'min_trans',parms.BOLD_min_trans,...
    'min_rot',parms.BOLD_min_rot,...
    'mc_flag',parms.BOLD_mc_flag,...
    'tshift_flag',parms.BOLD_tshift_flag,...
    'tpattern',parms.BOLD_tpattern,...
    'skipTRs',parms.BOLD_skipTRs,...
    'gradunwarp_flag',parms.BOLD_gradunwarp_flag,...
    'resample_flag',parms.BOLD_resample_flag,...
    'native_flag',parms.BOLD_native_flag,...
    'nvoxels',parms.BOLD_nvoxels,...
    'resolution',parms.BOLD_resolution,...
    'deoblique_flag',parms.BOLD_deoblique_flag,...
    'rot',parms.BOLD_rot,...
    'trans',parms.BOLD_trans,...
    'smooth',parms.BOLD_smooth,...
    'regT1flag',parms.BOLD_regT1flag,...
    'T1type',parms.STRUCT_T1type,...
    'bbregflag',parms.BOLD_bbregflag,...
    'cleanupflag',parms.BOLD_cleanupflag,...
    'forceflag',parms.forceflag);
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function parms = postprocess_data(parms)
  % additional structural processing
  if parms.STRUCT_BEMflag, run_BEM_surfs(parms); end;
  if parms.STRUCT_first_flag, run_FIRST_seg(parms); end; 
  % additional DTI processing
  if parms.DTI_calcDT_flag, run_Calc_DT(parms); end;
  if parms.DTI_calcRSI_flag, run_Calc_RSI(parms); end;
  if parms.DTI_export_flag, run_Export_DTI(parms); end;
  if parms.DTI_ATLflag, run_AtlasTrack(parms); end;
  if parms.DTI_CSD_tracto_flag, run_CSD_tracto(parms); end;
  % additional BOLD processing
  if parms.BOLD_export_flag, run_Export_BOLD(parms); end;
  if parms.BOLD_extract_tseries_flag, run_Extract_BOLD_tseries(parms); end;
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function run_BEM_surfs(parms)
  if ~parms.STRUCTflag || parms.STRUCT_errcode, return; end;
  if ~strcmp(parms.ContPaths.proc,parms.ContPaths.T1), return; end;
  MMIL_Make_BEM_Surfs(parms.ContPaths.T1,parms.ContPaths.fsurf,parms.forceflag);
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function run_FIRST_seg(parms)
  if ~parms.STRUCTflag || parms.STRUCT_errcode, return; end;
  if ~strcmp(parms.ContPaths.proc,parms.ContPaths.T1), return; end;
  if isempty(parms.ContPaths.fsurf)
    fprintf('%s: WARNING: STRUCT_first_flag=1 and FSContainerPath not found\n',...
      mfilename);
    return;
  end;
  MMIL_Process_First(parms.ContPaths.T1,...
    'T1type',parms.STRUCT_T1type,...
    'FSContainerPath',parms.ContPaths.fsurf,...
    'forceflag',parms.forceflag);
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function run_Calc_DT(parms)
  if ~parms.DTIflag || parms.DTI_errcode, return; end;
  DTI_MMIL_Calc_DT(parms.ContPaths.proc_dti,...
    'outdir',parms.DTI_DT_outdir,...
    'outfix',parms.DTI_DT_outfix,...
    'snums',parms.DTI_snums,...
    'infix',parms.DTI_infix,...
    'revflag',parms.DTI_revflag,...
    'nob0_flag',parms.DTI_nob0_flag,...
    'min_bval',parms.DTI_min_bval,...
    'max_bval',parms.DTI_max_bval,...
    'flex_flag',parms.DTI_flex_flag,...
    'min_ndirs',parms.DTI_min_ndirs,...
    'min_nb0',parms.DTI_min_nb0,...
    'nonlin_flag',parms.DTI_DT_nonlin_flag,...
    'regT1flag',parms.DTI_DT_regT1flag,...
    'nii_flag',parms.DTI_niiflag,...
    'nii_out_orient',parms.DTI_nii_out_orient,...
    'dat_flag',parms.DTI_datflag,...
    'mask_DTmeas_flag',parms.DTI_mask_DTmeas_flag,...
    'forceflag',parms.forceflag);
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function run_Calc_RSI(parms)
  if ~parms.DTIflag || parms.DTI_errcode, return; end;
  DTI_MMIL_Calc_RSI(parms.ContPaths.proc_dti,...
    'outdir',parms.DTI_RSI_outdir,...
    'outfix',parms.DTI_RSI_outfix,...
    'snums',parms.DTI_snums,...
    'infix',parms.DTI_infix,...
    'revflag',parms.DTI_revflag,...
    'nob0_flag',parms.DTI_nob0_flag,...
    'min_bval',parms.DTI_min_bval,...
    'flex_flag',parms.DTI_flex_flag,...
    'min_ndirs',parms.DTI_min_ndirs,...
    'min_nb0',parms.DTI_min_nb0,...
    'regT1flag',parms.DTI_RSI_regT1flag,...
    'nii_flag',parms.DTI_niiflag,...
    'nii_out_orient',parms.DTI_nii_out_orient,...
    'dat_flag',parms.DTI_datflag,...
    'mask_RSImeas_flag',parms.DTI_mask_RSImeas_flag,...
    'lambda',parms.DTI_RSI_lambda,...
    'iso_free_flag',parms.DTI_RSI_iso_free_flag,...
    'iso_hindered_flag',parms.DTI_RSI_iso_hindered_flag,...
    'iso_restricted_flag',parms.DTI_RSI_iso_restricted_flag,...
    'ADC_free',parms.DTI_RSI_ADC_free,...
    'ADC_hindered',parms.DTI_RSI_ADC_hindered,...
    'ADC_long',parms.DTI_RSI_ADC_long,...
    'ADC_trans_min',parms.DTI_RSI_ADC_trans_min,...
    'ADC_trans_max',parms.DTI_RSI_ADC_trans_max,...
    'num_ADC_trans',parms.DTI_RSI_num_ADC_trans,...
    'SH_order',parms.DTI_RSI_SH_order,...
    'norm_flag',parms.DTI_RSI_norm_flag,...
    'forceflag',parms.forceflag);
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function run_Export_DTI(parms)
  if ~parms.DTIflag || parms.DTI_errcode, return; end;
  ContainerPath = parms.ContPaths.proc_dti;
  switch parms.DTI_export_flag
    case 1
      DTI_MMIL_Export_Data(ContainerPath,...
        'outdir',[ContainerPath '/exportDTI'],...
        'snums',parms.DTI_snums,...
        'infix',parms.DTI_infix,...
        'revflag',parms.DTI_revflag,...
        'min_bval',parms.DTI_min_bval,...
        'flex_flag',parms.DTI_flex_flag,...
        'min_ndirs',parms.DTI_min_ndirs,...
        'min_nb0',parms.DTI_min_nb0,...
        'orient',parms.DTI_nii_out_orient,...
        'forceflag',parms.forceflag);
    case 2
       % will copy the DT measures also
       DTI_MMIL_Export_Data_for_FSL(parms.ContPaths.proc_dti,...
        'outdir',[ContainerPath '/exportDTIforFSL'],...
        'snums',parms.DTI_snums,...
        'infix',parms.DTI_infix,...
        'revflag',parms.DTI_revflag,...
        'min_bval',parms.DTI_min_bval,...
        'max_bval',parms.DTI_max_bval,...
        'flex_flag',parms.DTI_flex_flag,...
        'min_ndirs',parms.DTI_min_ndirs,...
        'min_nb0',parms.DTI_min_nb0,...
        'forceflag',parms.forceflag);
  end;
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function run_AtlasTrack(parms)
  if ~parms.DTIflag % if not running atlas tracks from DTI data
    if parms.STRUCT_errcode, return; end;
    if ~strcmp(parms.ContPaths.proc,parms.ContPaths.T1), return; end;
    infix = [];
    locflag = 1;
    create_paths_flag = 0;
    ContainerPath = parms.ContPaths.T1;
  else
    if parms.DTI_errcode, return; end;
    infix = parms.DTI_infix;
    locflag = parms.DTI_locflag;
    create_paths_flag = 1;
    ContainerPath = parms.ContPaths.proc_dti;
  end;
  if parms.DTI_xcg_flag && isempty(parms.ContPaths.fsurf)
    fprintf('%s: WARNING: DTI_xcg_flag=1 and FSContainerPath not found',...
      mfilename);
    parms.DTI_xcg_flag = 0;
  end;
  DTI_MMIL_AtlasTrack_Exam(ContainerPath,...
    'DT_outdir',parms.DTI_DT_outdir,...
    'DT_outfix',parms.DTI_DT_outfix,...
    'FSContainerPath',parms.ContPaths.fsurf,...
    'DTIflag',parms.DTIflag,...
    'T1type',parms.STRUCT_T1type,...
    'snums',parms.DTI_snums,...
    'infix',infix,...
    'revflag',parms.DTI_revflag,...
    'min_bval',parms.DTI_min_bval,...
    'max_bval',parms.DTI_max_bval,...
    'flex_flag',parms.DTI_flex_flag,...
    'min_nb0',parms.DTI_min_nb0,...
    'min_ndirs',parms.DTI_min_ndirs,...
    'nob0_flag',parms.DTI_nob0_flag,...
    'fibers',parms.DTI_fibers,...
    'subdiv_fibers',parms.DTI_subdiv_fibers,...
    'divide_fibers_flag',parms.DTI_divide_fibers_flag,...
    'combine_fibers_flag',parms.DTI_combine_fibers_flag,...
    'locflag',locflag,...
    'resT1flag',parms.DTI_fiber_resT1flag,...
    'regFA_flag',parms.DTI_ATL_regFA_flag,...
    'create_paths_flag',create_paths_flag,...
    'xcg_flag',parms.DTI_xcg_flag,...
    'xcg_suffix',parms.DTI_xcg_suffix,...
    'xcg_codes',parms.DTI_xcg_codes,...
    'masksf_flag',parms.DTI_masksf_flag,...
    'masksf_suffix',parms.DTI_masksf_suffix,...
    'fseg_flag',parms.DTI_fseg_flag,...
    'fseg_thresh_prob',parms.DTI_fseg_thresh_prob,...
    'atlasdir',parms.STRUCT_atlasdir,...
    'atlasname',parms.STRUCT_atlasname,...
    'fiber_atlasdir',parms.DTI_fiber_atlasdir,...
    'fiber_atlasname',parms.DTI_fiber_atlasname,...
    'forceflag',parms.forceflag);
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function run_CSD_tracto(parms)
  if ~parms.DTIflag || parms.DTI_errcode, return; end;
  DTI_MMIL_CSD_Tracto_Exam(parms.ContPaths.proc_dti,...
    'snums',parms.DTI_snums,...
    'infix',parms.DTI_infix,...
    'revflag',parms.DTI_revflag,...
    'min_bval',parms.DTI_min_bval,...
    'flex_flag',parms.DTI_flex_flag,...
    'seed_point_sampling',parms.DTI_CSD_seed_point_sampling,...
    'step_size',parms.DTI_CSD_step_size,...
    'FOD_thresh',parms.DTI_CSD_FOD_thresh,...
    'angle_thresh',parms.DTI_CSD_angle_thresh,...
    'fiber_length_range',parms.DTI_CSD_fiber_length_range,...
    'max_order',parms.DTI_CSD_max_order,...
    'FA_thresh',parms.DTI_CSD_FA_thresh,...
    'orient',parms.DTI_nii_out_orient,...
    'forceflag',parms.forceflag);
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function run_Export_BOLD(parms)
  if ~parms.BOLDflag || parms.BOLD_errcode, return; end;
  % export processed BOLD data as nii format (can be read by FSL)
  switch parms.BOLD_export_flag
    case 1
      errcode = BOLD_MMIL_Export_Data(parms.ContPaths.proc_bold,...
          'out_type',parms.BOLD_export_type,...
          'snums_valid',parms.BOLD_snums,...
          'infix',parms.BOLD_infix,...
          'out_orient',parms.BOLD_nii_out_orient,...
          'forceflag',parms.forceflag);
    case 2
      if isempty(parms.ContPaths.fsurf)
        fprintf('%s: WARNING: BOLD_export_flag=2 and FSContainerPath not found',...
          mfilename,parms.ContPaths.fsurf);
      end;
      errcode = BOLD_MMIL_Export_Data_for_FSL(parms.ContPaths.proc_bold,...
          parms.ContPaths.fsurf,...
          'snums_valid',parms.BOLD_snums,...
          'infix',parms.BOLD_infix,...
          'skipTRs',parms.BOLD_skipTRs,...
          'smooth',parms.BOLD_export_smooth,...
          'forceflag',parms.forceflag);
  end;
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function run_Extract_BOLD_tseries(parms)
  if ~parms.BOLDflag || parms.BOLD_errcode, return; end;
  errcode = BOLD_MMIL_Resting_Analysis(parms.ContPaths.proc_bold,...
      parms.ContPaths.fsurf,...
      'snums_valid',parms.BOLD_snums,...
      'infix',parms.BOLD_infix,...
      'forceflag',parms.forceflag,...
      'skipTRs',parms.BOLD_skipTRs,...
      'mc_flag',parms.BOLD_mc_flag,...
      'ico_flag',0,...
      'corr_roi_flag',0,...
      'outdir','BOLD_tseries');
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function write_progress_file(parms,step,errcode)
  if ~exist('errcode','var') || isempty(errcode)
    errcode = 0;
  end;
  if ~isfield(parms.ContPaths,'raw') ||...
     ~exist(parms.ContPaths.raw), return; end;
  fname = sprintf('%s/%s.txt',parms.ContPaths.raw,step);
  fid = fopen(fname,'a');
  if fid<0, error('failed to open %s for writing',fname); end;
  if errcode
    fprintf(fid,'%s finished with errors: %s\n',step,datestr(now));
  else
    fprintf(fid,'%s completed: %s\n',step,datestr(now));
  end;
  fclose(fid);
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

