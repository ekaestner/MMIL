function MMIL_Analyze_BOLD_Exam(ContainerPath,FSContainerPath,varargin)
%function MMIL_Analyze_BOLD_Exam(ContainerPath,FSContainerPath,[options])
%
% Usage:
%  MMIL_Analyze_BOLD_Exam(ContainerPath,FSContainerPath,'key1', value1,...)
%
% Required Parameters:
%   ContainerPath: full path of BOLDPROC directory containing processed BOLD data
%   FSContainerPath: full path of directory containing freesurfer recon
%
% Optional Polar Fourier Analysis Parameters:
%   'FP_flag': [0|1] whether to run polar Fourier analyses
%     for those subjects with FP_snums in StudyInfo
%     {default = 0}
%   'FP_snums': vector of scan numbers on which to run Fourier analysis
%     if empty, will skip Fourier analysis
%     {default = []}
%   'FP_revflags': vector of 0's or 1's to specify whether to reverse phase for each scan
%     {default = []} (zero for all)
%   'FP_skipTRs': number of TRs at beginning of each run to ignore
%     {default = 0}
%   'FP_phase_offset': fraction of cycles to subtract from phases to account for
%      hemodynamic delay
%     {default = 0.1}
%   'FP_phase_offset_postrev': fraction of cycles to subtract from phases
%      to account for stimulus delay
%     {default = 0}
%   'FP_stimfreq': stimulus frequency (cycles per scan)
%     {default = 8}
%   'FP_tksmooth': number of surface smoothing iterations for tksurfer script
%     (relevant only if paint_flag = 1)
%     {default = 2}
%   'FP_smoothsteps': smoothing steps on surface after painting
%     {default = 0}
%   'FP_sphsmoothsteps': smoothing steps on spherical surface
%     {default = 0}
%
% Optional Eccen Fourier Analysis Parameters:
%   'FE_flag': [0|1] whether to run eccen Fourier analyses
%     {default = 0}
%   'FE_snums': vector of scan numbers on which to run Fourier analysis
%     if empty, will skip Fourier analysis
%     {default = []}
%   'FE_revflags': vector of 0's or 1's to specify whether to reverse phase for each scan
%     {default = []} (zero for all)
%   'FE_skipTRs': number of TRs at beginning of each run to ignore
%     {default = 0}
%   'FE_phase_offset': fraction of cycles to subtract from phases to account for
%      hemodynamic delay
%     {default = 0.1}
%   'FE_phase_offset_postrev': fraction of cycles to subtract from phases
%      to account for stimulus delay
%     {default = 0}
%   'FE_stimfreq': stimulus frequency (cycles per scan)
%     {default = 8}
%   'FE_tksmooth': number of surface smoothing iterations for tksurfer script
%     (relevant only if paint_flag = 1)
%     {default = 2}
%   'FE_smoothsteps': smoothing steps on surface after painting
%     {default = 0}
%   'FE_sphsmoothsteps': smoothing steps on spherical surface
%     {default = 0}
%
% Optional GLM Analysis Parameters:
%   'GLM_flag': [0|1] whether to run GLM analyses
%     for those subjects with GLM_snums in StudyInfo
%     {default = 0}
%   'GLM_snums': vector of scan numbers on which to run GLM analysis
%     if empty, will skip GLM analysis
%     {default = []}
%   'GLM_concat_flag': [0|1] concatenate across multiple runs
%     Each scan will also be analyzed individually
%     {default = 1}
%   'GLM_skipTRs': number of TRs at beginning of each run to ignore
%     {default = 0}
%   'GLM_minlag': number of TRs for minimum "lag" between stimulus and response
%     {default = 0}
%   'GLM_maxlag': number of TRs for maximum "lag" between stimulus and response
%     {default = 4}
%   'GLM_tksmooth': number of surface smoothing iterations for tksurfer script
%     (relevant only if paint_flag = 1)
%     {default = 2}
%   'GLM_smoothsteps': smoothing steps on surface after painting
%     {default = 0}
%   'GLM_sphsmoothsteps': smoothing steps on spherical surface
%     {default = 0}
%   'GLM_stim_fnames': cell array of stimulus time course 1D files
%     specify only non-baseline conditions
%     each scan may have a different number of conditions, as specified by
%       GLM_num_conds
%     if empty, will skip GLM analysis
%     {default = []}
%   'GLM_num_conds': vector with number of conditions per scan
%     indicates how to read GLM_stim_fnames
%     if empty, will assume one condition per scan
%     {default = []}
%   'GLM_pthresh': probability threshold applied to f-stats for each
%     condition
%     {default = 0.05}
%   'GLM_contrasts_flag': [0|1] calculate glt contrasts between each condition
%     {default = 0}
%   'GLM_iresp_flag': [0|1] output impulse response functions for each condition
%     {default = 0}
%
% Optional GLM ROI Analysis Parameters:
%  'GLM_ROI_flag': [0|1] whether to run GLM ROI analysis
%    {default = 0}
%  'GLM_ROI_outstem': string added to output file names (appended to GLM stem)
%    {default = []}
%  'GLM_ROI_dir': full path of directory containing label files (e.g. lh.name.label)
%    If not empty, will calculate average ROI values for GLM analysis output
%    {default = []}
%  'GLM_ROI_stem': file stem for batch of labels (e.g. lh.{stem}_{name}.label)
%    {default = []}
%  'GLM_ROI_retfit_flag': [0|1] create visual area labels from retfit
%    If 1, label_dir and label_stem will be ignored
%    {default = 0}
%  'GLM_ROI_retfit_dir': full path of directory containing retfit results
%    {default = [ContainerPath '/retfit']}
%  'GLM_ROI_retfit_stem': file stem for retfit results
%    {default = 'retfit'}
%  'GLM_ROI_retfit_thresh': threshold applied to weights (relative to max for one area)
%    {default = 0}
%  'GLM_ROI_norm_flag': [0|1] normalize response function to last condition
%    {default = 1}
%  'GLM_ROI_iresp_flag': load GLM analysis results from iresp files (impulse response)
%    0: use summary statistics (i.e. area under curve)
%    1: use average of selected iresp time points
%    2: use entire iresp in estimation of response function
%    Requires that GLM_iresp_flag = 1
%    {default = 0}
%  'GLM_ROI_iresp_t0': first time point of iresp to include in average
%    {default = 1}
%  'GLM_ROI_iresp_t1': last time point of iresp to include in average
%    {default = Inf}
%  'GLM_ROI_iresp_baseline_flag': [0|1] subtract first time point from iresp timecourse
%    {default = 0}
%  'GLM_ROI_TR': repetition time (only used to calculate time vector for iresp)
%    {default = 1}
%  'GLM_ROI_weights_flag': [0|1] use weights loaded from mgh files as spatial prior
%    if retfit_flag = 1, weights will be calculated from retfit
%    {default = 0}
%  'GLM_ROI_weights_dir': full path of directory containing one or more weights files
%    must have corresponding weights file for each label in label_dir
%    If empty, will be set to label_dir
%    {default = []}
%  'GLM_ROI_combine_ROIs_flag': [0|1] combine results for ROIs with same name
%    {default = 0}
%  'GLM_ROI_names': cell array of ROI names to be combined
%    {default = {'v1','v2','v3'}}
%  'GLM_ROI_FSPath': FreeSurfer Container Path (required if retfit_flag = 1)
%    {default = []}
%  'GLM_ROI_cond_info': struct array containing condition information
%    see rc_read_cond_info
%    If cond_info and fname_conds are empty,
%      will create labels for entire visual areas
%    {default = []}
%  'GLM_ROI_fname_conds': full path of csv file containing condition information
%    Ignored if cond_info is supplied
%    {default = []}
%  'GLM_ROI_r_vec': vector of eccentricities (degrees visual angle)
%    Ignored if cond_info or fname_conds are supplied
%    {default = 7}
%  'GLM_ROI_th_vec' vector of polar angles (degrees)
%    Ignored if cond_info or fname_conds are supplied
%    {default = [45,135,225,315]}
%  'GLM_ROI_ecc_width': eccentricity width of stimuli (deg. vis. ang.)
%    Ignored if cond_info has ecc_width column
%    {default = 10}
%  'GLM_ROI_theta_width': polar angle width of stimuli (degrees)
%    Ignored if cond_info has theta_width column
%    will be ignored if fname_conds has theta_width column
%    {default = 90}
%  'GLM_ROI_r_max': maximum radius (degrees visual angle) used for eccentricity mapping
%    determines phase for a given eccentricity
%    {default = 12.5}
%  'GLM_ROI_rf_sizes': vector of receptive field sizes (degrees visual angle)
%    -- one for each visual area
%    {default = [0.66,1.03,1.88]}
%  'GLM_ROI_rf_slopes': vector of slopes of linear trend of receptive field sizes
%    w.r.t. ecc for each visual area
%    Intercept is assumed to be half of r_max
%    {default = [0.06,0.10,0.15]}
%  'GLM_ROI_surround_flag': [0|1] whether to model inhibitory surround with difference
%     of Gaussians; Requires vf2ctx_flag = 1
%    {default = 0}
%  'GLM_ROI_surround_rf_fact': size of surround receptive field relative to center
%    {default = 1.5}
%  'GLM_ROI_surround_amp_fact': amplitude of surround response relative to center
%    {default = 0.6}
%
% Optional Parameters:
%   'snums_valid': vector of scan numbers that were processed
%    if empty, will assume all were processed
%     {default = []}
%   'infix': BOLD file name infix (e.g. '', 'corr', 'corr_resBOLD')
%     {default = []}
%   'mc_flag': [0|1] whether within-scan motion correction was done
%     Will use motion.1D files as nuisance regressors for Fourier and GLM
%     {default = 1}
%   'mc_inter_flag': [0|1] whether between-scan motion correction was done
%     Allows for a single reference scan to be used for registration to FS
%     {default = 1}
%   'regFS_flag': [0|1] whether to register BOLD scans to FreeSurfer nu.mgz
%     if registration already done, will not redo
%     necessary for painting to surface
%     if 0 and not already done, paint_flag is ignored
%     {default = 0}
%   'fstats_type': [0|1|2] how output Fourier components should be scaled
%     0: raw, no scaling
%     1: scaled by sqrt(F-ratio)
%     2: scaled by significance values (-log10(p))
%    {default = 2}
%  'cxfstatsflag' [0|1] whether to calculate cross-scan complex f-stats
%    (in addition to amplitude f-stats)
%    {default = 1}
%  'paint_flag': [0|1|2] whether to paint results to surface
%     if 0, only do Fourier analysis, no painting to surface
%     if 1, paint results to surface after averaging across scans
%       (requires motion correction and register.dat file for first scan)
%     if 2, paint results to surface before averaging across scans
%       (requires register.dat file for each scan if not motion corrected)
%    {default = 1}
%  'projdist': dist (mm) to project along normal when painting
%    {default = 1}
%  'projfrac': fractional dist to project along normal when painting
%    {default = 0.5}
%  'projfrac_flag': [0|1] whether to use projfrac (1) or projdist (0)
%    {default = 0}
%  'projfrac_avg': vector of [min max del] for averaging multiple samples
%    If empty, use projfrac instead if projfrac_flag=1
%    {default = []}
%  'projdist_avg': vector of [min max del] for averaging multiple samples
%    If empty, use projdist instead
%    {default = []}
%  'resamp_flag': [0|1] whether to resample results to 1x1x1 before painting
%    {default = 0}
%  'force_repaint_flag': [0|1] whether to repaint even if output files exist
%    (do not redo volume calculations)
%    {default = 0}
%  'surfname': name of surface onto which to sample volume data
%    {default = white}
%  'sphere_flag': [0|1] whether to sample to icosohedral sphere after painting
%    {default = 0}
%  'forceflag': [0|1] whether to run calculations even if output files exist
%    {default = 0}
%
% Created:  09/01/08 by Don Hagler
% Last Mod: 03/07/13 by Don Hagler
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if ~mmil_check_nargs(nargin,2), return; end;
parms = mmil_args2parms(varargin, { ...
  'FP_flag',false,[false true],...
  'FP_datatype','polar',[],...
  'FP_snums',[],[],...
  'FP_revflags',[],[],...
  'FP_skipTRs',0,[0,1000],...
  'FP_phase_offset',0,[-1,1],...
  'FP_phase_offset_postrev',0,[-1,1],...
  'FP_stimfreq',8,[1,1000],...
  'FP_tksmooth',2,[0,1000],...
  'FP_smoothsteps',0,[0,1000],...
  'FP_sphsmoothsteps',0,[0,1000],...
...
  'FE_flag',false,[false true],...
  'FE_datatype','eccen',[],...
  'FE_snums',[],[],...
  'FE_revflags',[],[],...
  'FE_skipTRs',0,[0,1000],...
  'FE_phase_offset',0,[-1,1],...
  'FE_phase_offset_postrev',0,[-1,1],...
  'FE_stimfreq',8,[1,1000],...
  'FE_tksmooth',2,[0,1000],...
  'FE_smoothsteps',0,[0,1000],...
  'FE_sphsmoothsteps',0,[0,1000],...
...
  'GLM_flag',false,[false true],...
  'GLM_snums',[],[],...
  'GLM_concat_flag',true,[false true],...
  'GLM_contrasts_flag',false,[false true],...
  'GLM_iresp_flag',false,[false true],...
  'GLM_skipTRs',0,[0,1000],...
  'GLM_minlag',0,[0,10],...
  'GLM_maxlag',4,[0,30],...
  'GLM_tksmooth',2,[0,1000],...
  'GLM_stim_fnames',[],[],...
  'GLM_num_conds',[],[],...
  'GLM_smoothsteps',0,[0,1000],...
  'GLM_sphsmoothsteps',0,[0,1000],...
  'GLM_pthresh',0.05,[0,1],...
...
  'GLM_ROI_flag',false,[false true],...
  'GLM_ROI_outstem',[],[],...
  'GLM_ROI_dir',[],[],...
  'GLM_ROI_stem',[],[],...
  'GLM_ROI_norm_flag',true,[false true],...
  'GLM_ROI_iresp_flag',0,[0 1 2],...
  'GLM_ROI_iresp_t0',1,[1,Inf],...
  'GLM_ROI_iresp_t1',Inf,[1,Inf],...
  'GLM_ROI_iresp_baseline_flag',false,[false true],...
  'GLM_ROI_TR',1,[0.1,100],...
  'GLM_ROI_weights_flag',true,[false true],...
  'GLM_ROI_weights_dir',[],[],...
  'GLM_ROI_combine_ROIs_flag',false,[false true],...
  'GLM_ROI_names',{'v1','v2','v3'},[],...
  'GLM_ROI_retfit_flag',false,[false true],...
  'GLM_ROI_retfit_dir',[ContainerPath '/retfit'],[],...
  'GLM_ROI_retfit_stem','retfit',[],...
  'GLM_ROI_retfit_thresh',0,[],...
  'GLM_ROI_cond_info',[],[],...
  'GLM_ROI_fname_conds',[],[],...
  'GLM_ROI_r_vec',7,[],...
  'GLM_ROI_th_vec',[45,135,225,315],[],...
  'GLM_ROI_ecc_width',10,[0,100],...
  'GLM_ROI_theta_width',90,[0,360],...
  'GLM_ROI_r_max',12.5,[0,Inf],...
  'GLM_ROI_rf_sizes',[0.66,1.03,1.88],[],...
  'GLM_ROI_rf_slopes',[0.06,0.10,0.15],[0,10],...
  'GLM_ROI_surround_flag',false,[false true],...
  'GLM_ROI_surround_rf_fact',1.5,[],...
  'GLM_ROI_surround_amp_fact',0.6,[],...
...
  'snums_valid',[],[],...
  'infix',[],[],...
  'mc_flag',true,[false true],...
  'mc_inter_flag',true,[false true],...
  'regFS_flag',false,[false true],...
  'fstats_type',2,[0:2],...
  'cxfstatsflag',true,[false true],...
  'paint_flag',1,[0,2],...
  'projdist',1,[0,10],...
  'projfrac',0.5,[0,2],...
  'projfrac_flag',false,[false true],...
  'projdist_avg',[],[],...
  'projfrac_avg',[],[],...
  'resamp_flag',0,[0,1,2],...
  'force_repaint_flag',false,[false true],...
  'surfname','white',[],...
  'mask_midbrain_flag',false,[false true],...
  'sphere_flag',false,[false true],...
  'forceflag',false,[false true],...
...
  'fnamestem','BOLD',[],...
  'out_ext','.mgh',{'.mgh','.mgz'},...
});

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% get number of scans, etc.
[ScanInfo,SessInfo,errcode] = BOLD_MMIL_Get_ScanInfo(ContainerPath,...
  'snums',parms.snums_valid,'fnamestem',parms.fnamestem);
if errcode || isempty(ScanInfo), return; end;
fprintf('%s: %d BOLD scans in %s\n',mfilename,SessInfo.nscans,ContainerPath);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if parms.regFS_flag
  fname_T1 = sprintf('%s/mri/nu.mgz',FSContainerPath);
  BOLD_MMIL_Register_to_T1(...
    ContainerPath,...
    'fname_T1',fname_T1,...
    'snums',parms.snums_valid,...
    'infix',parms.infix,...
    'forceflag',parms.forceflag);
end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if parms.GLM_flag
  if isempty(parms.GLM_snums)
    parms.GLM_snums = [1:SessInfo.nscans];
  end;
  if any(~ismember(parms.GLM_snums,1:SessInfo.nscans))
    error('bad scan numbers in GLM_snums');
  end;
  GLM_nscans = length(parms.GLM_snums);
  fprintf('%s: number of GLM scans = %d\n',mfilename,GLM_nscans);
  if (GLM_nscans~=0)
    if isempty(parms.GLM_stim_fnames)
      fprintf('%s: WARNING: GLM_stim_fnames not specified... skipping\n');
    else
      if isempty(parms.GLM_num_conds)
        parms.GLM_num_conds = ones(GLM_nscans,1);
      end;
      if length(parms.GLM_num_conds) ~= GLM_nscans
        error('number of elements in GLM_num_conds (%d) does not match number of scans (%d)',...
          length(parms.GLM_num_conds),GLM_nscans);
      end;
      if ~iscell(parms.GLM_stim_fnames)
        parms.GLM_stim_fnames = {parms.GLM_stim_fnames};
      end;
      if length(parms.GLM_stim_fnames) ~= sum(parms.GLM_num_conds)
        error('number of elements in GLM_stim_fnames (%d) does not match sum of GLM_num_conds (%d)',...
          length(parms.GLM_stim_fnames),sum(parms.GLM_num_conds));
      end;
      fprintf('%s: analyzing scans with GLM: [ %s]\n',...
        mfilename,sprintf('%d ',parms.GLM_snums));
      BOLD_MMIL_GLM_Analysis(...
        ContainerPath,parms.GLM_stim_fnames,...
        'num_conds',parms.GLM_num_conds,...
        'FSPath',FSContainerPath,...
        'snums_valid',parms.snums_valid,...
        'snums',parms.GLM_snums,...
        'concat_flag',parms.GLM_concat_flag,...
        'contrasts_flag',parms.GLM_contrasts_flag,...
        'iresp_flag',parms.GLM_iresp_flag,...
        'infix',parms.infix,...
        'skipTRs',parms.GLM_skipTRs,...
        'minlag',parms.GLM_minlag,...
        'maxlag',parms.GLM_maxlag,...
        'tksmooth',parms.GLM_tksmooth,...
        'smoothsteps',parms.GLM_smoothsteps,...
        'sphsmoothsteps',parms.GLM_sphsmoothsteps,...
        'mc_flag',parms.mc_flag,...
        'mc_inter_flag',parms.mc_inter_flag,...
        'paint_flag',parms.paint_flag,...
        'projdist',parms.projdist,...
        'projfrac',parms.projfrac,...
        'projfrac_flag',parms.projfrac_flag,...
        'projdist_avg',parms.projdist_avg,...
        'projfrac_avg',parms.projfrac_avg,...
        'force_repaint_flag',parms.force_repaint_flag,...
        'resamp_flag',parms.resamp_flag,...
        'pthresh',parms.GLM_pthresh,...
        'surfname',parms.surfname,...
        'sphere_flag',parms.sphere_flag,...
        'out_ext',parms.out_ext,...
        'fnamestem',parms.fnamestem,...
        'forceflag',parms.forceflag);

      if ~isempty(parms.GLM_ROI_dir) || parms.GLM_ROI_retfit_flag
        if parms.GLM_ROI_iresp_flag && ~parms.GLM_iresp_flag
          fprintf('%s: WARNING: GLM_ROI_iresp_flag = %d, but GLM_iresp_flag = %d\n',...
            mfilename,parms.GLM_ROI_iresp_flag,parms.GLM_iresp_flag);
        else
          fprintf('%s: performing GLM ROI analysis...\n',mfilename);
          BOLD_MMIL_GLM_ROI_Analysis(...
            ContainerPath,...
            'FSPath',FSContainerPath,...
            'outstem',parms.GLM_ROI_outstem,...
            'label_dir',parms.GLM_ROI_dir,...
            'label_stem',parms.GLM_ROI_stem,...
            'snums_valid',parms.snums_valid,...
            'snums',parms.GLM_snums,...
            'concat_flag',parms.GLM_concat_flag,...
            'infix',parms.infix,...
            'norm_flag',parms.GLM_ROI_norm_flag,...
            'iresp_flag',parms.GLM_ROI_iresp_flag,...
            'iresp_t0',parms.GLM_ROI_iresp_t0,...
            'iresp_t1',parms.GLM_ROI_iresp_t1,...
            'iresp_baseline_flag',parms.GLM_ROI_iresp_baseline_flag,...
            'TR',parms.GLM_ROI_TR,...
            'weights_flag',parms.GLM_ROI_weights_flag,...
            'weights_dir',parms.GLM_ROI_weights_dir,...
            'combine_ROIs_flag',parms.GLM_ROI_combine_ROIs_flag,...
            'ROI_names',parms.GLM_ROI_names,...
            'retfit_flag',parms.GLM_ROI_retfit_flag,...
            'retfit_dir',parms.GLM_ROI_retfit_dir,...
            'retfit_stem',parms.GLM_ROI_retfit_stem,...
            'retfit_thresh',parms.GLM_ROI_retfit_thresh,...
            'cond_info',parms.GLM_ROI_cond_info,...
            'fname_conds',parms.GLM_ROI_fname_conds,...
            'r_vec',parms.GLM_ROI_r_vec,...
            'th_vec',parms.GLM_ROI_th_vec,...
            'ecc_width',parms.GLM_ROI_ecc_width,...
            'theta_width',parms.GLM_ROI_theta_width,...
            'r_max',parms.GLM_ROI_r_max,...
            'rf_sizes',parms.GLM_ROI_rf_sizes,...
            'rf_slopes',parms.GLM_ROI_rf_slopes,...
            'surround_flag',parms.GLM_ROI_surround_flag,...
            'surround_rf_fact',parms.GLM_ROI_surround_rf_fact,...
            'surround_amp_fact',parms.GLM_ROI_surround_amp_fact,...
            'fnamestem',parms.fnamestem,...
            'forceflag',parms.forceflag);
        end;
      end;
    end;
  end;
end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if parms.FP_flag
  if isempty(parms.FP_snums)
    parms.FP_snums = [1:SessInfo.nscans];
  end;
  if any(~ismember(parms.FP_snums,1:SessInfo.nscans))
    error('bad scan numbers in FP_snums');
  end;
  FP_nscans = length(parms.FP_snums);
  fprintf('%s: number of polar Fourier scans = %d\n',mfilename,FP_nscans);
  if (FP_nscans~=0)
    fprintf('%s: analyzing polar scans with Fourier: [ %s]\n',...
      mfilename,sprintf('%d ',parms.FP_snums));
    if isempty(parms.FP_revflags)
      parms.FP_revflags = zeros(FP_nscans,1);
      for i=1:FP_nscans
        if mod(i,2), parms.FP_revflags(i) = 1; end; % odd scans are rev
      end;
    end;
    BOLD_MMIL_Fourier_Analysis(...
      ContainerPath,...
      'FSPath',FSContainerPath,...
      'snums',parms.FP_snums,...
      'snums_valid',parms.snums_valid,...
      'infix',parms.infix,...
      'revflags',parms.FP_revflags,...
      'stimfreq',parms.FP_stimfreq,...
      'skipTRs',parms.FP_skipTRs,...
      'phase_offset',parms.FP_phase_offset,...
      'phase_offset_postrev',parms.FP_phase_offset_postrev,...
      'datatype',parms.FP_datatype,...
      'tksmooth',parms.FP_tksmooth,...
      'smoothsteps',parms.FP_smoothsteps,...
      'sphsmoothsteps',parms.FP_sphsmoothsteps,...
      'mc_flag',parms.mc_flag,...
      'mc_inter_flag',parms.mc_inter_flag,...
      'fstats_type',parms.fstats_type,...
      'cxfstatsflag',parms.cxfstatsflag,...
      'paint_flag',parms.paint_flag,...
      'projdist',parms.projdist,...
      'projfrac',parms.projfrac,...
      'projfrac_flag',parms.projfrac_flag,...
      'projdist_avg',parms.projdist_avg,...
      'projfrac_avg',parms.projfrac_avg,...
      'force_repaint_flag',parms.force_repaint_flag,...
      'resamp_flag',parms.resamp_flag,...
      'surfname',parms.surfname,...
      'sphere_flag',parms.sphere_flag,...
      'out_ext',parms.out_ext,...
      'fnamestem',parms.fnamestem,...
      'forceflag',parms.forceflag);
  end;
end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if parms.FE_flag
  if isempty(parms.FE_snums)
    parms.FE_snums = [1:SessInfo.nscans];
  end;
  if any(~ismember(parms.FE_snums,1:SessInfo.nscans))
    error('bad scan numbers in FE_snums');
  end;
  FE_nscans = length(parms.FE_snums);
  fprintf('%s: number of eccen Fourier scans = %d\n',mfilename,FE_nscans);
  if (FE_nscans~=0)
    fprintf('%s: analyzing eccen scans with Fourier: [ %s]\n',...
      mfilename,sprintf('%d ',parms.FE_snums));
    if isempty(parms.FE_revflags)
      parms.FE_revflags = zeros(FE_nscans,1);
      for i=1:FE_nscans
        if mod(i,2), parms.FE_revflags(i) = 1; end; % odd scans are rev
      end;
    end;
    BOLD_MMIL_Fourier_Analysis(...
      ContainerPath,...
      'FSPath',FSContainerPath,...
      'snums',parms.FE_snums,...
      'snums_valid',parms.snums_valid,...
      'infix',parms.infix,...
      'revflags',parms.FE_revflags,...
      'stimfreq',parms.FE_stimfreq,...
      'skipTRs',parms.FE_skipTRs,...
      'phase_offset',parms.FE_phase_offset,...
      'phase_offset_postrev',parms.FE_phase_offset_postrev,...
      'datatype',parms.FE_datatype,...
      'tksmooth',parms.FE_tksmooth,...
      'smoothsteps',parms.FE_smoothsteps,...
      'sphsmoothsteps',parms.FE_sphsmoothsteps,...
      'mc_flag',parms.mc_flag,...
      'mc_inter_flag',parms.mc_inter_flag,...
      'fstats_type',parms.fstats_type,...
      'cxfstatsflag',parms.cxfstatsflag,...
      'paint_flag',parms.paint_flag,...
      'projdist',parms.projdist,...
      'projfrac',parms.projfrac,...
      'projfrac_flag',parms.projfrac_flag,...
      'projdist_avg',parms.projdist_avg,...
      'projfrac_avg',parms.projfrac_avg,...
      'force_repaint_flag',parms.force_repaint_flag,...
      'resamp_flag',parms.resamp_flag,...
      'surfname',parms.surfname,...
      'sphere_flag',parms.sphere_flag,...
      'out_ext',parms.out_ext,...
      'fnamestem',parms.fnamestem,...
      'forceflag',parms.forceflag);
  end;
end;
