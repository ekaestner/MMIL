function rc_synth_RCSE_offsets(subj,varargin)
%function rc_synth_RCSE_offsets(subj,[options])
%
% Purpose: synthesize sensor data from RCSE, add noise
%   then re-estimate source waveforms (and residual error) with RCSE
%     with random offsets
%
% Usage:
%  rc_synth_RCSE_noise(subj,'key1', value1,...);
%
% Optional Inupt:
%  'rootdir': directory containing matfiles dir for output RCSE
%     {default = pwd}
%  'RCSE_prefix': prefix of RCSE input files for source waveforms
%     {default = 'RCSE'}
%  'RCSE_rootdir': directory containing matfiles dir for input RCSE sources
%     If empty, rootdir
%     {default = rootdir}
%  'RCSE_forward_prefix': prefix of RCSE output files for forward solution
%     If empty, RCSE_prefix
%     {default = []}
%  'RCSE_forward_rootdir': directory containing matfiles dir for RCSE forward
%     If empty, rootdir
%     {default = []}
%  'offsets_outfix': output file stem RCSE with offsets
%     {default = 'offsets'}
%  'noise_outfix':  output file stem for RCSE plus noise
%     {default = 'noise'}
%  'offsets_flag': [0|1] re-estimate RCSE waveforms with random dipole offsets
%     {default = 1}
%  'noise_flag': [0|1] synthesize sensor waveforms plus noise then re-estimate RCSE waveforms
%     {default = 1}
%  'offsets_r_step': standard deviation of gaussian step size for rand offset search
%    {default = 0.01}
%  'offsets_th_step': standard deviation of gaussian step size for rand offset search
%    {default = 0.01}
%  'r_offset_range': vector of min and max r_offsets for rand offset search
%    If 0, no bounds
%    {default = [-0.02,0.02]}
%  'th_offset_range': vector of min and max th_offsets for rand offset search
%    If 0, no bounds
%    {default = [-0.02,0.02]}
%  'fiterr_flag': which type of sensor data
%    0: use RCSE fitted data plus noise
%    1: use residual error of RCSE fit
%    2: use RCSE fit projected into sensor data
%    3: use data minus RCSE fit projected into sensor data
%     {default = 0}
%  'sources': matrix of source time courses
%     if empty, will use RCSE estimated source time courses
%     size must be [ntpoints,narea,ncontrasts]
%     only used if fiterr_flag = 0
%    {default = []}
%  'areas': when fiterr_flag=0, use only these area numbers
%    if empty, use all areas
%    {default = []}
%  'fstem_conds': stem of csv file containing condition information
%    {default = 'cond_info'}
%  'conditions' - vector of condition numbers (index to avg_data.averages)
%     defining subset of stimulus locations in retmap to use
%     If empty, use all conditions in retmap.cond_order
%       or conditions in cond_info with non-zero contrast
%     {default = []}
%  'event_codes' - vector of event codes to use
%     defining subset of stimulus conditions in cond_info to use
%     If empty, use all conditions in cond_info with non-zero contrast
%     If specified, 'conditions' will be ignored
%     {default = []}
%  'sourcefact': amplitude of modeled sources
%     {default = 1}
%  'baselineflag': use repeated baseline as noise added to synth_data
%     otherwise use gaussian noise
%     {default = 1}
%  'fif_flag': [0|1] whether to save synthesized sensor data to fif file
%     {default = 0}
%  'template_fif': template fif file (e.g. raw or online avg)
%     Required for saving synthesized data to fif file
%     {default = []}
%  'subjdir': freesurfer root subject dir
%    {default = []}
%
% NOTE: this function relies on having pre-run rc_RCSE
%
% Created:  07/08/11 by Don Hagler
% Last Mod: 11/01/13 by Don Hagler
%

if ~mmil_check_nargs(nargin,1), return; end;
parms = mmil_args2parms(varargin, { ...
  'rootdir',pwd,[],...
  'RCSE_prefix','RCSE',[],...
  'RCSE_rootdir',[],[],...
  'RCSE_forward_prefix',[],[],...
  'RCSE_forward_rootdir',[],[],...
  'offsets_outfix','offsets',[],...
  'noise_outfix','noise',[],...
...
  'offsets_flag',true,[false true],...
  'noise_flag',true,[false true],...
  'grid_offset_flag',true,[false true],...
  'offsets_r_step',0.01,[0,10],...
  'offsets_th_step',0.01,[0,90],...
  'r_offset_range',[-0.02,0.02],[-100,100],...
  'th_offset_range',[-0.02,0.02],[-180,180],...
...
  'fiterr_flag',0,[0:3],...
  'sources',[],[],...
  'areas',[],[],...
  'conditions',[],[],...
  'sourcefact',1,[0,Inf],...
  'baselineflag',true,[false true],...
  'fif_flag',false,[false true],...
  'template_fif',[],[],...
  'subjdir',[],[],...
...
  'retfit_dir','retfit',[],...
...
  'forward_matfile',[],[],...
  'indy_locs_flag',false,[false true],...
  'graymid_flag',false,[false true],...
  'calc_dipinfo_flag',true,[false true],...
  'inverse_type',1,[0:2],...
  'ncov_type',1,[0,1,2],...
  'SNR',10,[eps Inf],...
  'plotflag',1,[0 1 2 3],...
  'forceflag',0,[0:2],...
... % conditions
  'fstem_conds','cond_info',[],...
  'cond_offsets_flag',0,[0 1 2],...
  'hemivec',[1,2],[1,1,2],...
  'uplowvec',[1,2],[1,1,2],...
  'eccvec',[],[],...
  'thetavec',[],[],...
  'contvec',[],[],...
  'sfvec',[],[],...
  'colvec',[],[],...
... % retfit
  'retfit_dir','retfit',[],...
  'retfit_stem','retfit',[],...
  'vf2ctx_flag',true,[false true],...
  'stim_type',2,[0:2],...
  'use_areas',[],[],...
  'r_offset',0,[-100,100],...
  'th_offset',0,[-180,180],...
  'r_step',0.002,[1e-4,10],...
  'th_step',0.002,[1e-4,90],...
  'r_max',12.5,[0,Inf],...
  'ecc_width',1,[0,100],...
  'theta_width',10,[0,360],...
  'w_thresh',0.01,[0,100],...
  'single_vertex_flag',0,[0 1 2],...
  'rf_sizes',[0.66,1.03,1.88],[0.01,10],...
  'rf_slopes',[0.06,0.10,0.15],[0,10],...
  'restrict_hemi_flag',false,[false true],...
  'restrict_uplow_flag',false,[false true],...
  'restrict_flag',false,[false true],...
  'retfit_data_flag',false,[false true],...
... % fitting
  'polarity_penalty',0,[-Inf,Inf],...
  'fit_range_flag',false,[false true],...
  'fit_time0',80,[-Inf,Inf],...
  'fit_time1',120,[-Inf,Inf],...
  'fmincon_flag',false,[false true],...
  'offset_niters',0,[0,Inf],...
  'max_offset_niters',Inf,[0,Inf],...
  'offset_mstarts',0,[0,Inf],...
  'mstart_rotsearch_flag',false,[false true],...
  'mstart_rfsearch_flag',false,[false true],...
  'mstart_randstart_flag',true,[false true],...
  'mstart_average_flag',true,[false true],...
  'reweight_flag',true,[false true],...
  'reweight_factor',2,[],...
  'reweight_maxiter',100,[],...
  'reweight_tol',1e-7,[],...
  'reweight_leverage_flag',true,[false true],...
  'reweight_leverage_max_flag',true,[false true],...
  'hybrid_flag',false,[false true],...
  'hybrid_pre_niters',0,[0,Inf],...
  'offset_niters_last',0,[0,Inf],...
  'offset_group_flag',0,[0 1 2 3 4],...
  'offset_group_patches_flag',false,[false true],...
  'offset_group_areas_flag',false,[false true],...
  'offset_const_areas',[],[],...
  'grid_offset_smooth',0,[0,1000],...
  'rot_niters',0,[0,Inf],...
  'rot_step',1,[0,180],...
  'rot_max',10,[0,180],...
  'best_rot',[0 0 0],[-180 180],...
  'rscale_niters',0,[0,Inf],...
  'rscale_step',1,[0,180],...
  'rscale_range',[0.8,1.2],[0.1,10],...
  'best_rscale',1,[0.1,10],...
  'nbrhd_niters',0,[0,Inf],...
  'nbrhd_full_flag',false,[false true],...
  'prior_prefix',[],[],...
  'prior_weight',0.5,[0,1],...
  'prior_avg_flag',0,[0:3],...
  'prior_mindiff_flag',0,[0 1 2],...
  'prior_indy_wform_flag',false,[false true],...
  'corr_time0',0,[-Inf,Inf],...
  'corr_time1',170,[-Inf,Inf],...
  'best_retmap_prefix',[],[],...
  'err_prefix',[],[],...
  'rf_niters',0,[0,Inf],...
  'rf_min_sizes',[0.1,0.1,0.1],[0.01,10],...
  'rf_max_sizes',[3,3,3],[0.01,10],...
  'rf_min_slopes',[0,0,0],[0,10],...
  'rf_max_slopes',[0.2,0.2,0.2],[0,10],...
  'rf_size_step',0.1,[0.01,10],...
  'rf_slope_step',0.01,[0.001,1],...
  'calc_scalefacts_flag',false,[false true],...
  'bem_flag',true,[false true],...
  'conductivities',[0.3 0.012 0.3],[],...
  'EEG_gain_scalefact',1,[-Inf Inf],...
  'nlayers',1,[1,1,3],...
  'bem_surf_files',{'bem/inner_skull4.tri'},[],...
  'usegrad_flag',true,[false true],...
  'usemag_flag',false,[false true],...
  'useEEG_flag',false,[false true],...
  'indy_smfact',0.999,[0,1],...
  'ecc_smfact',0,[0,1],...
  'upperlower_smfact',0,[0,1],...
  'hemi_smfact',0,[0,1],...
  'loose_flag',false,[false true],...
  'loose_tang_weight',0.5,[0,1],...
  'condF_thresh',0,[],...
  'dip_matfile',[],[],...
  'ret_dips_lh_dec_file',[],[],...
  'ret_dips_rh_dec_file',[],[],...
  'ret_dip_qfield_flag',true,[false true],...
  'nonret_dips_lh_dec_file',[],[],...
  'nonret_dips_rh_dec_file',[],[],...
  'ret_dips_weight',0,[0,1],...
  'nonret_dips_weight',0,[0,1],...
  'norm_weights_flag',2,[0 1 2 3],...
  'area_names',{'v1','v2','v3'},[],...
  'plot_outdir','RCSE_plots',[],...
  'plot_normflag',false,[false true],...
  'plot_ylim',[-30,30],[-Inf,Inf],...
  'save_avg_flag',true,[false true],...
  'write_err_flag',false,[false true],...
  'write_fit_flag',false,[false true],...
  'write_areafit_flag',false,[false true],...
  'write_fif_flag',false,[false true],...
  'template_fif',[],[],...
});

cwd = pwd;

if isempty(parms.RCSE_rootdir)
  parms.RCSE_rootdir = parms.rootdir;
end;
if isempty(parms.RCSE_forward_rootdir)
  parms.RCSE_forward_rootdir = parms.RCSE_rootdir;
end;
if isempty(parms.RCSE_forward_prefix)
  parms.RCSE_forward_prefix = parms.RCSE_prefix;
end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% load parms for RCSE source
fname = sprintf('%s/matfiles/%s_parms.mat',...
  parms.RCSE_rootdir,parms.RCSE_prefix);
if ~exist(fname,'file'), error('file %s not found',fname); end;
tmp = load(fname);
RCSE_source_parms = tmp.parms;

% load parms for RCSE forward
fname = sprintf('%s/matfiles/%s_parms.mat',...
  parms.RCSE_forward_rootdir,parms.RCSE_forward_prefix);
if ~exist(fname,'file'), error('file %s not found',fname); end;
tmp = load(fname);
RCSE_forward_parms = tmp.parms;

% load avg data
fname = sprintf('%s/matfiles/%s_avg_data.mat',...
  parms.RCSE_forward_rootdir,parms.RCSE_prefix);
if ~exist(fname,'file'), error('file %s not found',fname); end;
load(fname);

% merge parms with RCSE parms so we could override existing settings if desired
RCSE_parms = RCSE_forward_parms;
fields = fieldnames(parms);
for f=1:length(fields)
  RCSE_parms.(fields{f}) = parms.(fields{f});
end;

% set some more RCSE parameters
RCSE_parms.rootoutdir = parms.rootdir;
if ~isempty(RCSE_parms.forward_matfile) &...
    mmil_isrelative(RCSE_parms.forward_matfile)
  RCSE_parms.forward_matfile = sprintf('%s/matfiles/%s',...
    parms.RCSE_forward_rootdir,RCSE_parms.forward_matfile);
end;
if ~isempty(parms.use_areas)
  RCSE_parms.use_areas = parms.use_areas;
end;
if isempty(RCSE_parms.use_areas)
  RCSE_parms.use_areas = 1:RCSE_parms.nareas;
end;
RCSE_parms.use_areas = find(ismember(1:RCSE_parms.nareas,RCSE_parms.use_areas));

% restrict flags determine number of offsets
if parms.offsets_flag
  RCSE_parms.offset_infix_list = {''};
  if ~RCSE_parms.restrict_hemi_flag
    RCSE_parms.offset_infix_list{end+1} = '_ipsi';
  end;
  if ~RCSE_parms.restrict_uplow_flag
    RCSE_parms.offset_infix_list{end+1} = '_cross';
  end;
  if ~RCSE_parms.restrict_hemi_flag && ~RCSE_parms.restrict_uplow_flag
    RCSE_parms.offset_infix_list{end+1} = '_ipsi_cross';
  end;
  RCSE_parms.npatches = length(RCSE_parms.offset_infix_list);
  RCSE_parms.offset_types = {'r','th'};
end;

% use all conditions and areas if not specified
if isempty(parms.conditions)
  parms.conditions = [1:length(avg_data.averages)];
end;
if isempty(parms.areas)
  parms.areas = [1:RCSE_forward_parms.nareas];
end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

RCSE_parms.prefix = parms.RCSE_prefix;
if parms.noise_flag
  RCSE_parms.prefix = [RCSE_parms.prefix '_' parms.noise_outfix];
end;
if parms.offsets_flag
  RCSE_parms.prefix = [RCSE_parms.prefix '_' parms.offsets_outfix];
end;

if parms.noise_flag
  tmp_outdir = [parms.rootdir '/matfiles'];
  mmil_mkdir(tmp_outdir);
  RCSE_parms.datamatfile = sprintf('%s/%s_synth_data.mat',...
    tmp_outdir,RCSE_parms.prefix);
  if ~exist(RCSE_parms.datamatfile,'file') || parms.forceflag
    % synthesize data from RCSE source estimates + noise
    tags = {'fiterr_flag','areas',...
            'sourcefact','baselineflag','sources'};
    args = mmil_parms2args(parms,tags);
    synth_data = rc_synth_sensors_from_RCSE(...
      'rootdir',parms.RCSE_rootdir,...
      'prefix',parms.RCSE_prefix,...
      'forward_rootdir',parms.RCSE_forward_rootdir,...
      'forward_prefix',parms.RCSE_forward_prefix,...
      args{:});

    if parms.fif_flag
      tmp_outdir = [parms.rootdir '/fifs'];
      mmil_mkdir(tmp_outdir);
      tmp_outstem = sprintf('%s/%s_%s',...
        tmp_outdir,parms.noise_outfix,parms.RCSE_prefix);
      tmp_data = synth_data;
      tmp_data.averages = tmp_data.averages(parms.conditions);
      ts_avg2fif(tmp_data,parms.template_fif,tmp_outstem,1);
    end;

    % save synth_data to mat file
    avg_data = synth_data;
    save(RCSE_parms.datamatfile,'avg_data');
  end;
else
  RCSE_parms.datamatfile = sprintf('%s/matfiles/%s_avg_data.mat',...
    parms.RCSE_rootdir,parms.RCSE_prefix);
end;

% run RCSE with random offsets
if parms.offsets_flag
  tmp_outdir = [parms.rootdir '/csvfiles'];
  mmil_mkdir(tmp_outdir);
  RCSE_parms.fname_conds = sprintf('%s/%s_cond_info.csv',...
    tmp_outdir,parms.offsets_outfix);
  if ~exist(RCSE_parms.fname_conds,'file') || parms.forceflag
    fname_conds = [parms.fstem_conds '.csv'];
    cond_info = rc_read_cond_info(fname_conds);
    nconds = length(cond_info);
    % find unique locations from cond_info
    same_location_conds = [1:nconds]';
    if isfield(cond_info,'contrast')
      contrasts = [cond_info.contrast];
    else
      contrasts = ones(1,nconds);
    end;
    ind_stim = find(contrasts>0); % all except null condition (or excluded)
    uniq_contrasts = unique(contrasts(ind_stim));
    ncontrasts = length(uniq_contrasts);
    if isfield(cond_info,'spatfreq')
      spatfreqs = [cond_info.spatfreq];
    elseif isfield(cond_info,'sfreq')
      spatfreqs = [cond_info.sfreq];
    else
      spatfreqs = ones(1,nconds);
    end;
    uniq_spatfreqs = unique(spatfreqs(ind_stim));
    nspatfreqs = length(uniq_spatfreqs);
    if isfield(cond_info,'coltype')
      coltypes = [cond_info.coltype];
    else
      coltypes = ones(1,nconds);
    end;
    uniq_coltypes = unique(coltypes(ind_stim));
    ncoltypes = length(uniq_coltypes);
    if ncontrasts>1 || nspatfreqs>1 || ncoltypes>1
      for i=nconds:-1:2
        r = cond_info(i).ecc;
        th = cond_info(i).theta;
        for j=1:i-1
          tmp_r = cond_info(j).ecc;
          tmp_th = cond_info(j).theta;
          if tmp_r==r & tmp_th==th
            same_location_conds(i) = j;
            break;
          end;
        end;
      end;
    end;
    uniq_location_conds = unique(same_location_conds);
    % set location number for each cond, save in cond_info
    for i=1:nconds
      cond_info(i).loc_num = ...
        find(uniq_location_conds==...
             same_location_conds(i));
    end;

    RCSE_parms.offset_niters = 1;
    RCSE_parms.cond_info = cond_info;
    RCSE_parms = rc_RCSE_check_conds(RCSE_parms,avg_data);
    RCSE_parms.offset_niters = parms.offset_niters;

    % select random offset steps for each area and condition
    r_steps = parms.offsets_r_step*randn(RCSE_parms.nareas,RCSE_parms.nconds,RCSE_parms.npatches);
    th_steps = parms.offsets_th_step*randn(RCSE_parms.nareas,RCSE_parms.nconds,RCSE_parms.npatches);
    % force some conditions to have same steps (e.g. within quad)
    for i=1:RCSE_parms.nconds
      j=RCSE_parms.offset_group_conds(i);
      if i==j, continue; end;
      r_steps(:,i,:) = r_steps(:,j,:);
      th_steps(:,i,:) = th_steps(:,j,:);
    end;
    if RCSE_parms.offset_group_patches_flag % force patches to have same offsets
      for p=2:RCSE_parms.npatches
        r_steps(:,:,p) = r_steps(:,:,1);
        th_steps(:,:,p) = th_steps(:,:,1);
      end;
    end;
    if RCSE_parms.offset_group_areas_flag % force areas to have same offsets
      for a=2:RCSE_parms.nareas
        r_steps(a,:,:) = r_steps(1,:,:);
        th_steps(a,:,:) = th_steps(1,:,:);
      end;
    end;
    for k=1:length(RCSE_parms.offset_const_areas)
      % keep offsets constant (set to zero)
      a = RCSE_parms.offset_const_areas(k);
      r_steps(a,:,:) = 0;
      th_steps(a,:,:) = 0;
    end;
    tmp_cond_info = rc_RCSE_set_cond_info_offsets(RCSE_parms,r_steps,th_steps);
    tmp_loc_nums = cell2mat({tmp_cond_info.loc_num});

    for i=1:length(cond_info)
      % find condition in tmp_cond_info with same stim location
      loc_num = cond_info(i).loc_num;
      j = find(loc_num==tmp_loc_nums);
      if isempty(j), continue; end;
      for a=RCSE_parms.use_areas
        for t=1:length(RCSE_parms.offset_types)
          for p=1:RCSE_parms.npatches
            fieldname = sprintf('%s_offset_%s%s',...
              RCSE_parms.offset_types{t},RCSE_parms.area_names{a},...
              RCSE_parms.offset_infix_list{p});
            if isfield(tmp_cond_info,fieldname)
              val = tmp_cond_info(j).(fieldname);
            else
              val = 0;
            end;
            cond_info(i).(fieldname) = val;
          end;
        end;
      end;
    end;
    rc_write_cond_info(cond_info,RCSE_parms.fname_conds,parms.forceflag);
  end;
  [tpath,tstem] = fileparts(RCSE_parms.fname_conds);
  RCSE_parms.fstem_conds = [tpath '/' tstem];
else
  RCSE_parms.fstem_conds = parms.fstem_conds;
end;

% run RCSE on synth_data
RCSE_args = MMIL_Args(RCSE_parms,'rc_RCSE');
cd(parms.rootdir)
rc_RCSE(subj,RCSE_args{:});
cd(cwd);


