function sim_data=rc_simret(input_prefix,varargin);
%function sim_data=rc_simret(input_prefix,[options]);
%
% Purpose:simulate retinotopy sensor waveforms
%
% Usage:
%  sim_data=rc_simret(input_prefix,'key1',value1,...);
%
% Required Input:
%  input_prefix - prefix of input mat files generated by RCSE.m
%
% Optional parameters:
%  'rootoutdir': root output directory
%    (subdirectories will be created and/or assumed to exist)
%    {default = pwd} (current working directory)
%  'prefix': prefix of all output files
%     {default = 'sim_ret'}
%  'use_areas': vector of area numbers defining subset of visual areas
%     defined in retmap to use
%     {default = []} (if empty, use input parms.use_areas)
%  'sim_sources_flag': [0|1] simulate sources using rc_simulate_sources
%     function; otherwise, use sources estimated with ret_inv
%     {default = 0}
%  'calc_noise_facts_flag': [0|1] whether to calculate noise factors from
%     average data baselines (otherwise use input noise_fact values)
%     {default = 1}
%  'grad_noise_fact': st.dev. of gaussian noise (relative to grad_scalefact)
%     added to output gradiometer sensor waveforms
%     {default = 2}
%  'mag_noise_fact': st.dev. of gaussian noise (relative to mag_scalefact)
%     added to output magnetometer sensor waveforms
%     {default = 3}
%  'EEG_noise_fact': st.dev. of gaussian noise (relative to mag_scalefact)
%     added to output EEG sensor waveforms
%     {default = 0.1}
%  'noise_fact': overall noise factor, to test generalized effects of noise
%     this value is multiplied by grad_noise_fact, mag_noise_fact, and EEG_noise_fact
%     {default = 1}
%  'write_fif_flag': [0|1] Toggle output of simulated data
%     sensor waveforms as fif files (displayable by Neuromag's xplotter)
%     {default = 0}
%  'template_fif': full path name of online average fif file
%     must specify if write_fif_flag=1
%     {default = []}
%
% Created:  10/09/06 by Don Hagler
% Last Mod: 11/01/13 by Don Hagler
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if ~mmil_check_nargs(nargin,1), return; end;
tmp_parms = mmil_args2parms(varargin, { ...
  'rootoutdir',pwd,[],...
  'prefix','sim_ret',[],...
  'use_areas',[],[],...
  'sim_sources_flag',false,[false true],...
  'grad_noise_fact',2,[],...
  'mag_noise_fact',3,[],...
  'EEG_noise_fact',0.1,[],...
  'noise_fact',1,[],...
  'write_fif_flag',false,[false true],...
  'template_fif',[],[],...
  'calc_noise_facts_flag',true,[false true],...
});

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% check parameters

cd(tmp_parms.rootoutdir);

fprintf('%s: loading parms from RCSE...\n',mfilename);
matfile = sprintf('matfiles/%s_parms.mat',input_prefix);
if ~exist(matfile,'file')
  error('file %s not found',matfile);
end;
load(matfile);
input_parms = parms;

if parms.indy_locs_flag || parms.loose_flag
  error('only full RCSE is supported (not indy locs or loose)');
end;

fprintf('%s: loading data...\n',mfilename);
matfile = sprintf('matfiles/%s_avg_data.mat',input_prefix);
if ~exist(matfile,'file')
  error('file %s not found',matfile);
  return;
end;
load(matfile);

fprintf('%s: loading pre-calculated forward solution...\n',mfilename);
if isempty(input_parms.forward_matfile)
  parms.forward_matfile = sprintf('matfiles/%s_forward.mat',input_prefix);
else
  parms.forward_matfile = input_parms.forward_matfile;
end;
if ~exist(parms.forward_matfile,'file')
  error('file %s not found',parms.forward_matfile);
  return;
end;
load(parms.forward_matfile);
G_xyz = forward.G_xyz;
lh_dip_info = forward.lh_dip_info;
rh_dip_info = forward.rh_dip_info;
lh_dec_dips = forward.lh_dec_dips;
rh_dec_dips = forward.rh_dec_dips;

matfile=sprintf('matfiles/%s_ret_forward.mat',input_prefix);
if ~exist(matfile,'file')
  error('file %s not found',matfile);
  return;
end;
load(matfile);
retmap = retforward.retmap;
full_retmap = retforward.full_retmap;
F = retforward.F;
num_areas = length(retmap.areas);
% save retintopy forward (for plotting)
matfile=sprintf('matfiles/%s_ret_forward.mat',parms.prefix);
save(matfile,'retforward');

orig_use_areas = parms.use_areas;
if isempty(orig_use_areas)
  orig_use_areas = [1:num_areas];
end;
orig_num_use_areas = length(orig_use_areas);

if isempty(tmp_parms.use_areas)
  tmp_parms.use_areas = orig_use_areas;
elseif ~all(ismember(tmp_parms.use_areas,orig_use_areas))
  error('use_areas contains an area number not found in input parms.use_areas');
end;
num_use_areas = length(tmp_parms.use_areas);

parms.input_prefix = input_prefix;
parms.prefix = tmp_parms.prefix;
parms.use_areas = tmp_parms.use_areas;
parms.sim_sources_flag = tmp_parms.sim_sources_flag;
parms.calc_noise_facts_flag = tmp_parms.calc_noise_facts_flag;
parms.grad_noise_fact = tmp_parms.grad_noise_fact;
parms.mag_noise_fact = tmp_parms.mag_noise_fact;
parms.EEG_noise_fact = tmp_parms.EEG_noise_fact;
parms.noise_fact = tmp_parms.noise_fact;
parms.write_fif_flag = tmp_parms.write_fif_flag;
parms.template_fif = tmp_parms.template_fif;
clear tmp_parms;

if parms.write_fif_flag
  if ~exist(parms.template_fif)
    error('template_fif %s not found',parms.template_fif);
  end
end

% create output subdirs
!mkdir -p matfiles
if(parms.write_fif_flag)
  !mkdir -p fifs
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% create scale matrix for data
[num_sensors,num_tpoints] = size(avg_data.averages(1).data);
scalefacts = zeros(parms.nchans,1);
scalefacts(parms.grad_chans)=parms.grad_scalefact;
scalefacts(parms.mag_chans)=parms.mag_scalefact;
scalefacts(parms.EEG_chans)=parms.EEG_scalefact;
scale_matrix = scalefacts*ones(1,num_tpoints);
inv_scale_matrix = ones(size(scale_matrix));
inv_scale_matrix(find(scale_matrix))=1./scale_matrix(find(scale_matrix));

% calculate noise scaling factors
if parms.calc_noise_facts_flag
  fprintf('%s: calculating scaling factors from average data...\n',...
    mfilename);
  navg=0;
  C = zeros(parms.nchans);
  for c=1:length(parms.conditions)
    cond = parms.conditions(c);
    time = avg_data.averages(cond).time;
    data = avg_data.averages(cond).data.*scale_matrix;
    baseline = data(:,parms.baseline_start_samp:parms.baseline_end_samp);
    mean_base=mean(baseline')';
    data=data-mean_base*ones(1,size(data,2));  % correct baseline
    baseline = data(:,parms.baseline_start_samp:parms.baseline_end_samp);
    C=C+diag(std(baseline').^2);  % diag covariance matrix
    navg=navg+1;
  end;
  C = C/navg;
  noise_facts = sqrt(diag(C));
  parms.grad_chans = setdiff(parms.grad_chans,parms.badchans);
  parms.mag_chans = setdiff(parms.mag_chans,parms.badchans);
  parms.EEG_chans = setdiff(parms.EEG_chans,parms.badchans);
  if isempty(parms.grad_chans)
    parms.grad_noise_fact = 0;
  else
    parms.grad_noise_fact = mean(noise_facts(parms.grad_chans))*parms.noise_fact;
  end;
  if isempty(parms.mag_chans)
    parms.mag_noise_fact = 0;
  else
    parms.mag_noise_fact = mean(noise_facts(parms.mag_chans))*parms.noise_fact;
  end;
  if isempty(parms.EEG_chans)
    parms.EEG_noise_fact = 0;
  else
    parms.EEG_noise_fact = mean(noise_facts(parms.EEG_chans))*parms.noise_fact;
  end;
end;

fprintf('%s: noise factors: grad=%0.5g, mag=%0.5g, EEG=%0.5g\n',...
  mfilename,parms.grad_noise_fact,parms.mag_noise_fact,parms.EEG_noise_fact);

% save parms as matfile (for future reference)
fprintf('%s: saving parameters to mat file...\n',mfilename);
matfile=sprintf('matfiles/%s_parms.mat',parms.prefix);
save(matfile,'parms','input_parms');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% create scale matrix for noise
[num_sensors,num_tpoints] = size(avg_data.averages(1).data);
noise_facts = zeros(parms.nchans,1);
noise_facts(parms.grad_chans)=parms.grad_noise_fact;
noise_facts(parms.mag_chans)=parms.mag_noise_fact;
noise_facts(parms.EEG_chans)=parms.EEG_noise_fact;
noise_scale_matrix = noise_facts*ones(1,num_tpoints);

% scale gain matrix
fprintf('%s: scaling gain matrix...\n',mfilename);
% scale to get to units of data, then scale with scalefacts
% and scale EEG part with EEG_gain_scalefact
scalefacts = zeros(parms.nchans,1);
scalefacts(parms.grad_chans)=GRAD_UNITSFACT*parms.grad_scalefact;
scalefacts(parms.mag_chans)=MAG_UNITSFACT*parms.mag_scalefact;
scalefacts(parms.EEG_chans)=EEG_UNITSFACT*parms.EEG_scalefact*parms.EEG_gain_scalefact;
scale_matrix = scalefacts*ones(1,size(G_xyz,2));
G_xyz = G_xyz.*scale_matrix;

% convert xyz to normal and two orthogonal tangential components
fprintf('%s: converting xyz components to normal and tangentials\n',mfilename);
[G_norm,G_tang1,G_tang2]=ts_gain_xyz2norm(G_xyz,lh_dip_info,...
  rh_dip_info,lh_dec_dips,rh_dec_dips,parms.trans);

% resize to remove unwanted and bad chans
fprintf('%s: resizing gain matrix to remove bad channels...\n',mfilename);
G_xyz = G_xyz(parms.goodchans,:);
G_norm = G_norm(parms.goodchans,:);
G_tang1 = G_tang1(parms.goodchans,:);
G_tang2 = G_tang2(parms.goodchans,:);
num_dec_dips_lh=length(find(lh_dec_dips));
num_dec_dips_rh=length(find(rh_dec_dips));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% todo: allow to selectively use simulated or estimated sources for each area or dip
total_areas = num_use_areas + retmap.num_ret_dips + retmap.num_nonret_dips;
if parms.sim_sources_flag
  % simulate source waveforms
  fprintf('%s: simulating source waveforms...\n',mfilename);
  sfreq = avg_data.sfreq;
  tmin = avg_data.averages(1).time(1);
  tmax = avg_data.averages(1).time(end);
  waveforms=rc_simulate_sources(total_areas,sfreq,tmin,tmax);
else
  % use sources estimated from actual data
  fprintf('%s: loading pre-calculated source estimates...\n',mfilename);
  matfile=sprintf('matfiles/%s_results.mat',input_prefix);
  if ~exist(matfile,'file')
    error('file %s not found',matfile);
    return;
  end;
  load(matfile);
  retmap = results.retmap;
  waveforms=zeros(total_areas,length(retmap.areas(1).time));

  % retinotopic map areas
  for ind_a=1:num_use_areas
    a = parms.use_areas(ind_a);
    tmp = retmap.areas(a).amplitudes;
    if size(tmp,2)>1, tmp = mean(tmp,2); end;
    waveforms(ind_a,:) = tmp;
  end;
  ind_a = num_use_areas;

  % pseudo-retinotopic dipoles
  for d=1:length(retmap.ret_dips)
    ind_a = ind_a + 1;
    % average across ret_dip_locs (e.g. quarterfields)
    wf = 0;
    for q=1:retmap.num_ret_dip_locs
      wf = wf + retmap.ret_dips(d).n(:,q); % normal component only
    end;
    wf = wf / retmap.num_ret_dip_locs;
    waveforms(ind_a,:) = wf;
  end

  % non-retinotopic dipoles
  for d=1:length(retmap.nonret_dips)
    ind_a = ind_a + 1;
    wf = retmap.nonret_dips(d).n; % normal component only
    waveforms(ind_a,:) = wf;
  end
end;

% calculate sensor waveforms
fprintf('%s: calculating sensor waveforms...\n',mfilename);
num_tpoints = length(avg_data.averages(1).time);
num_measurements = num_sensors*retmap.num_locs;
num_sources = size(F,2);
results.S = zeros(num_tpoints,num_sources);

%if num_sources ~= total_areas
%  error('num_sources (%d) should be same as total_areas (%d)',...
%    num_sources,total_areas);
%end;

% retinotopic map areas
for i=1:orig_num_use_areas
  oa = orig_use_areas(i);
  ind_a = find(parms.use_areas==oa);
  if isempty(ind_a), continue; end;
  results.S(:,i)=waveforms(ind_a,:);
end
ind_a = num_use_areas;

% pseudo-retinotopic dipoles
s0=orig_num_use_areas;
for d=1:length(retmap.ret_dips)
  ind_a = ind_a + 1; % next waveform
  if strcmp('lh',retmap.ret_dips(d).hemisphere)
    j = find(retmap.lh_ret_dips_v==retmap.ret_dips(d).v);
  elseif strcmp('rh',retmap.ret_dips(d).hemisphere)
    j = length(retmap.lh_ret_dips_v) + find(retmap.rh_ret_dips_v==retmap.ret_dips(d).v);
  else
    j = [];
  end;
  if isempty(j)
    error('failed to extract ret_dips');
  end;
  s = s0 + (j-1)*3*retmap.num_ret_dip_locs + 1;
  % quarterfields: upper right, lower right, upper left, lower left
  for q=1:retmap.num_ret_dip_locs
    S(:,s) = waveforms(ind_a,:);
    s=s+3; % leave tangential components zero
  end
end

% non-retinotopic dipoles
s0 = s0 + retmap.num_ret_dips*3*retmap.num_ret_dip_locs;
for d=1:length(retmap.nonret_dips)
  ind_a = ind_a + 1; % next waveform
  if strcmp('lh',retmap.nonret_dips(d).hemisphere)
    j = find(retmap.lh_nonret_dips_v==retmap.nonret_dips(d).v);
  elseif strcmp('rh',retmap.nonret_dips(d).hemisphere)
    j = length(retmap.lh_nonret_dips_v) + find(retmap.rh_nonret_dips_v==retmap.nonret_dips(d).v);
  else
    j = [];
  end;
  s = s0 + (j-1)*3 + 1;
  results.S(:,s) = waveforms(ind_a,:);
  s=s+1;
end

results.Y = zeros(num_tpoints,num_measurements);
results.Y = (F*results.S')';
results.Yfit = results.Y;

% add noise to sensors
for c=1:length(retmap.cond_order)
  cond = retmap.cond_order(c);
  k1=1+length(parms.goodchans)*(c-1);
  k2=k1+length(parms.goodchans)-1;
  tmp_data = zeros(size(avg_data.averages(c).data));
  tmp_data(parms.goodchans,:)=results.Y(:,k1:k2)';
  tmp_noise=randn(size(tmp_data)).*noise_scale_matrix;
  results.Y(:,k1:k2)=(tmp_data(parms.goodchans,:)+tmp_noise(parms.goodchans,:))';
end;  

% calculate error (not really meaningful, just so plotting scripts don't choke)
results.E = results.Y-results.Yfit;
results.var_E = var(results.E,0,2);
results.var_Y = var(results.Y,0,2);
results.norm_var_E = zeros(size(results.E));

% extract source time courses
fprintf('%s: extracting source time courses...\n',mfilename);
j=1;
for i=1:retmap.num_areas
  if parms.loose_flag
    retmap.areas(i).amplitudes = results.S(:,j:3:j+3*retmap.num_locs-1);
    j=j+3*retmap.num_locs;
  elseif parms.indy_locs_flag
    retmap.areas(i).amplitudes = results.S(:,j:j+retmap.num_locs-1);
    j=j+retmap.num_locs;
  else
    retmap.areas(i).amplitudes = results.S(:,i);
    j=j+1;
  end
  retmap.areas(i).time = avg_data.averages(1).time;
end
s0=j-1;

% extract source waveforms for extra dips
for d=1:length(retmap.ret_dips)
  if strcmp('lh',retmap.ret_dips(d).hemisphere)
    j = find(retmap.lh_ret_dips_v==retmap.ret_dips(d).v);
  elseif strcmp('rh',retmap.ret_dips(d).hemisphere)
    j = length(retmap.lh_ret_dips_v) + find(retmap.rh_ret_dips_v==retmap.ret_dips(d).v);
  else
    j = [];
  end;
  if isempty(j)
    error('failed to extract ret_dips');
  end;
  s = s0 + (j-1)*3*retmap.num_ret_dip_locs + 1;
  % quarterfields: upper right, lower right, upper left, lower left
  for q=1:retmap.num_ret_dip_locs
    n = S(:,s); s=s+1;
    retmap.ret_dips(d).n(:,q) = n; % norm
    t1 = S(:,s); s=s+1;
    retmap.ret_dips(d).t1(:,q) = t1; % tang1
    t2 = S(:,s); s=s+1;
    retmap.ret_dips(d).t2(:,q) = t2; % tang2

    for t=1:num_tpoints
      retmap.ret_dips(d).a(t,q) = sqrt(n(t)^2 + t1(t)^2 + t2(t)^2);
    end
  end
end
s0 = s0 + retmap.num_ret_dips*3*retmap.num_ret_dip_locs;
for d=1:length(retmap.nonret_dips)
  if strcmp('lh',retmap.nonret_dips(d).hemisphere)
    j = find(retmap.lh_nonret_dips_v==retmap.nonret_dips(d).v);
  elseif strcmp('rh',retmap.nonret_dips(d).hemisphere)
    j = length(retmap.lh_nonret_dips_v) + find(retmap.rh_nonret_dips_v==retmap.nonret_dips(d).v);
  else
    j = [];
  end;
  s = s0 + (j-1)*3 + 1;
  n = S(:,s); s=s+1;
  retmap.nonret_dips(d).n = n;
  t1 = S(:,s); s=s+1;
  retmap.nonret_dips(d).t1 = t1;
  t2 = S(:,s); s=s+1;
  retmap.nonret_dips(d).t2 = t2;
  for t=1:num_tpoints
    retmap.nonret_dips(d).a(t) = sqrt(n(t)^2 + t1(t)^2 + t2(t)^2);
  end
end
results.retmap = retmap;
% save results
matfile=sprintf('matfiles/%s_results.mat',parms.prefix);
fprintf('%s: saving results to %s...\n',mfilename,matfile);
save(matfile,'results');

% create simulated data structures
fprintf('%s: creating simulated data structure...\n',mfilename);
sim_data = [];
sim_data.num_sensors = avg_data.num_sensors;
sim_data.sfreq = avg_data.sfreq;
sim_data.sensor_info = avg_data.sensor_info;
sim_data.coor_trans = avg_data.coor_trans;
sim_data.noise = avg_data.noise;
for c=1:length(avg_data.averages)
  sim_data.averages(c).event_code=avg_data.averages(c).event_code;
  sim_data.averages(c).num_trials=avg_data.averages(c).num_trials;
  sim_data.averages(c).num_rejects=avg_data.averages(c).num_rejects;
  sim_data.averages(c).time=avg_data.averages(c).time;
  sim_data.averages(c).data=zeros(size(avg_data.averages(c).data));
  sim_data.averages(c).stdev=zeros(size(avg_data.averages(c).stdev));
end;
for c=1:length(retmap.cond_order)
  cond = retmap.cond_order(c);
  k1=1+length(parms.goodchans)*(c-1);
  k2=k1+length(parms.goodchans)-1;
  sim_data.averages(cond).data(parms.goodchans,:)=results.Y(:,k1:k2)';
  sim_data.averages(cond).data = sim_data.averages(cond).data.*inv_scale_matrix;
end;  
avg_data = sim_data;

matfile=sprintf('matfiles/%s_avg_data.mat',parms.prefix);
save(matfile,'avg_data');

% write to fif
if(parms.write_fif_flag)
  out_fif_dir = 'sim_fifs';
  if ~exist(out_fif_dir), mkdir('sim_fifs'); end;
  outstem=sprintf('%s/%s_sim_data',out_fif_dir,parms.prefix);
  fprintf('%s: writing simulated data to fif...\n',mfilename);
  ts_avg2fif(sim_data,parms.template_fif,outstem,1);
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

fprintf('%s: finished.\n',mfilename);
return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

