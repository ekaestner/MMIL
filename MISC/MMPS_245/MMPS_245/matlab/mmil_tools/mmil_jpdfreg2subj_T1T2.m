function M_T1_to_T2 = mmil_jpdfreg2subj_T1T2(fname_T1,fname_T2,varargin)
% function M_T1_to_T2 = mmil_jpdfreg2subj_T1T2(fname_T1,fname_T2,[options])
%
% Purpose: perform rigid body registration between
%   T2-weighted and T1-weighted MRI volumes (uses Dominic Holland's reg)
%   Registers T1 and T2 MRI volumes in subject space
%
% Usage: mmil_jpdfreg2subj_T1T2(fname_T2,fname_T1,'key1',val1,...)
%
% Required Input:
%   fname_T1: full path file name of T1-weighted volume (mgh/mgz format)
%   fname_T2: full path file name of T2-weighted volume (mgh/mgz format)
%
% Optional Input:
%   'outdir': output path for files generated by reg
%     {default = pwd}
%   'fname_T1_mask': full path of brain mask for T1-weighted volume
%     If not supplied, will create the T1 mask using mmil_dct_brainmask
%     {default = []}
%   'paramfile': full or relative path of parameter file
%     If relative, relative to $MMPS_PARMS/REG
%     {default = []}
%   'binfile': full or relative path of reg binary file
%     {default = 'reg'}
%   'logfile': file name of output log file
%     If relative, relative to outdir
%     {default = 'reg.log'}
%   'atlasdir': full path of atlas directory
%     {default =  [getenv('MMPS_DIR') '/atlases']}}
%   'atlasname': name of atlas file (omit .mat extension)
%     full path or relative to atlasdir
%     {default =  'T1_Atlas/T1_atlas'}
%   'cleanup_flag': [0|1] removes files created by mmil_reg to correct 
%     for residual translation {default =1}
%   'forceflag': [0|1] overwrite existing output files
%     {default = 0}
% 
% Created:  01/24/12 by Vijay Venkatraman
% Prev Mod: 05/11/17 by Don Hagler
% Last Mod: 08/03/17 by Don Hagler
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% parse input parameters

M_T1_to_T2 = [];
if ~mmil_check_nargs(nargin,2), return; end;
parms = mmil_args2parms(varargin, { ...
  'fname_T1',fname_T1,[],...
  'fname_T2',fname_T2,[],...
  'outdir',pwd,[],...
  'fname_T1_mask',[],[],...
  'paramfile',[],[],...
  'binfile','reg',[],...
  'logfile','reg.log',[],...
  'forceflag',false,[false true],...
...
  'atlasdir',[],[],...
  'atlasname','T1_Atlas/T1_atlas',[],...  
  'bindir',[],[],...
  'parmsdir',[],[],...
  'sincflag',true,[false true],...
  'interpm',2,[1:5],...
  'cleanup_flag',true,[false true],...
...
  'smoothmask_flag',true,[false,true],...
  'thresh0',0.01,[0,1000],...
  'smooth1',10,[0,100],...
  'thresh1',0.5,[0,1],...
  'smooth2',5,[0,100],...
  'thresh2',0.5,[0,1],...
  'smooth3',5,[0,100],...
  'thresh3',0.3,[0,1],...  
});

nvox_LIA = [256 256 256,1];
M_LIA =  [-1     0     0   129;...
           0     0     1  -129;...
           0    -1     0   129;...
           0     0     0     1];

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% check parms

% check parameter file
if ~isempty(parms.paramfile)
  if isempty(parms.parmsdir)
    parms.parmsdir = [getenv('MMPS_PARMS') '/REG'];
  end;
  if isempty(regexp(parms.paramfile,'^/')) % relative path
    parms.paramfile = [parms.parmsdir '/' parms.paramfile];
  end;
  if ~exist(parms.paramfile,'file')
    error('parameter file %s not found',parms.paramfile);
  end;
end;

% check binary
if isempty(parms.bindir)
  parms.bindir = [getenv('MMPS_DIR') '/bin'];
end;
if isempty(regexp(parms.binfile,'^/')) % relative path
  parms.binfile = [parms.bindir '/' parms.binfile];
end;
if ~exist(parms.binfile,'file')
  error('binary file %s not found',parms.binfile);
end;

% check atlas files
if isempty(parms.atlasdir)
  parms.atlasdir = [getenv('MMPS_DIR') '/atlases'];
end;
if ~exist(parms.atlasdir,'dir')
  error('atlas directory %s not found',parms.atlasdir);
end;

% set the directory for T1/T2 atlas
parms.T1T2atlasdir = [parms.atlasdir '/T1T2'];
if ~exist(parms.T1T2atlasdir,'dir')
  error('T1/T2 atlas directory %s not found',parms.T1T2atlasdir);
end;

parms.fname_atlasT2 = [parms.T1T2atlasdir '/atlasT2.mgz'];
parms.fname_atlasT2_mask = [parms.T1T2atlasdir '/maskT2.mgz'];
if ~exist(parms.fname_atlasT2,'file')
  error('atlas T2 file %s not found',parms.fname_atlasT2);
end;
if ~exist(parms.fname_atlasT2_mask,'file')
  error('mask T2 file %s not found',parms.fname_atlasT2_mask);
end;

parms.fname_atlasT1 = [parms.T1T2atlasdir '/atlasT1.mgz'];
if ~exist(parms.fname_atlasT1,'file')
  error('atlas T1 file %s not found',parms.fname_atlasT1);
end;

% check input files
if ~exist(parms.fname_T1,'file')
  error('file %s not found',parms.fname_T1);
end;
if ~exist(parms.fname_T2,'file')
  error('file %s not found',parms.fname_T2);
end;

% create output dir if needed
mmil_mkdir(parms.outdir);

% check input mask file
if isempty(parms.fname_T1_mask) | ~exist(parms.fname_T1_mask,'file')
  [vol_in,mr_parms] = ctx_load_mgh(parms.fname_T1);
  parms.fname_T1_mask = [parms.outdir '/T1mask.mgz'];
  [vol_out,M_Atl_to_Subj] = mmil_dct_brainmask(vol_in,'fname_mask',parms.fname_T1_mask,...
    'atlasname',parms.atlasname,'atlasdir',parms.atlasdir,'forceflag',parms.forceflag);
  clear vol_in M_Atl_to_Subj;
  voltmp = vol_out; 
  voltmp.imgs(:) = 0;
  voltmp.imgs = 1.0*(vol_out.imgs>0.5);  
  ctx_save_mgh(voltmp,parms.fname_T1_mask);  
  clear voltmp vol_out;
end;

% fname_T1_mask is a binary mask, smoothing is done here for mmil_reg
if parms.smoothmask_flag
  [vol_in, mr_parms] =  ctx_load_mgh(parms.fname_T1_mask);
  [T1pathstr,T1stem,T1ext] = fileparts(parms.fname_T1_mask);
  parms.fname_T1_mask = sprintf('%s/%s_sm%s',parms.outdir,T1stem,T1ext);
  vol_out = mmil_dilate_mask(vol_in,'thresh0',parms.thresh0,'smooth1',parms.smooth1,...
    'thresh1',parms.thresh1,'smooth2',parms.smooth2,'thresh2',parms.thresh2,...
    'smooth3',parms.smooth3,'thresh3',parms.thresh3);
  ctx_save_mgh(vol_out, parms.fname_T1_mask); 
  clear vol_in vol_out; 
end;

% get info about input files
[M_T1,volsz_T1] = fs_read_header(parms.fname_T1);
[M_T2,volsz_T2] = fs_read_header(parms.fname_T2);
[tmp,tstem_T1,text_T1] = fileparts(parms.fname_T1);
[tmp,tstem_T2,text_T2] = fileparts(parms.fname_T2);
% get info about atlas files
[tmp,tstem_T1atl,text_T1atl] = fileparts(parms.fname_atlasT1);
[tmp,tstem_T2atl,text_T2atl] = fileparts(parms.fname_atlasT2);
[tmp,tstem_T2atlmask,text_T2atlmask]= fileparts(parms.fname_atlasT2_mask);

% set full log file name
if isempty(regexp(parms.logfile,'^/'))
  parms.logfile = [parms.outdir '/' parms.logfile];
end;
if exist(parms.logfile,'file')
  tmpstr = '\n####################################################\n';
else
  tmpstr = [];
end;
mmil_logstr(parms,'%s start registration %s\n',tmpstr,datestr(now));

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% register T1 atlas to T1

outdir = [parms.outdir '/atlT1_to_subjT1_01'];
fname_atlT1_regmat = [outdir '/M_T1_to_T1atl_AffReg.mat'];
fname_atlT1_regtxt = [outdir '/M_T1_to_T1atl_AffReg.txt'];
fname_atl_T1 = [outdir '/' tstem_T1atl '_Subj.mgz'];
tags = {'interpm','logfile','binfile','paramfile','cleanup_flag'};
args = mmil_parms2args(parms,tags);
M_T1_to_T1atl = mmil_reg(parms.fname_T1,parms.fname_atlasT1,args{:},...
  'rigid_flag',1,'affine_flag',1,...
  'outdir',outdir,...
  'fname_maskA', parms.fname_T1_mask,...
  'fname_regmat',fname_atlT1_regmat,...
  'fname_regtxt',fname_atlT1_regtxt,...
  'fname_regout',fname_atl_T1);
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Apply M_T1_to_T1atl to atlas T2 and atlas T2 mask

[vol1,mrparms1,volsz1] = ctx_load_mgh(parms.fname_T1);
[vol2,mrparms2,volsz2] = ctx_load_mgh(parms.fname_atlasT2);
% resample the atlasT2
% cubic interpm hardcoded, use same interpolation as T1 atlas to T1.
vol2r= vol_resample_pad(vol2,vol1,M_T1_to_T1atl,2,1);
fname_atl_T2 = [outdir '/' tstem_T2atl '_SubjT1.mgz'];
ctx_save_mgh(vol2r,fname_atl_T2,mrparms1);
clear vol2 vol2r;
% resample the atlasT2 mask
[vol2,mrparms2,volsz2]= ctx_load_mgh(parms.fname_atlasT2_mask);
vol2r= vol_resample_pad(vol2,vol1,M_T1_to_T1atl,0,1);
fname_atlmask_T2 = [outdir '/' tstem_T2atlmask '_SubjT1.mgz'];
ctx_save_mgh(vol2r,fname_atlmask_T2,mrparms1);
clear vol1 vol2 vol2r;
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Combine the masks of parms.fname_T1_mask and fname_atlmask_T2

[volT1m,mrparmsT1m,volszT1m] = ctx_load_mgh(parms.fname_T1_mask);
[volT2m,mrparmsT2m,volszT2m] = ctx_load_mgh(fname_atlmask_T2);
vol_cmask= volT2m;vol_cmask.imgs = 0; 
vol_cmask.imgs = volT1m.imgs .* volT2m.imgs;
ind= find(vol_cmask.imgs<0.1);
vol_cmask.imgs(ind)=0;
fname_mask_combine= [outdir '/T1T2_mask.mgz'];
ctx_save_mgh(vol_cmask,fname_mask_combine,mrparmsT2m);
clear vol_cmask volT1m volT2m;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Register T2 to atlas T2 in T1 space

outdir = [parms.outdir '/T2_to_atlT2_01'];
fname_atlT2T1toT2_regmat = [outdir '/M_T1_to_T2_itr0.mat'];
fname_atlT2T1toT2_regtxt = [outdir '/M_T1_to_T2_itr0.txt'];
fname_atlT2T1_T2 = [outdir '/' tstem_T2 '_atlT2toT2.mgz'];
tags = {'interpm','logfile','binfile','paramfile','cleanup_flag'};
args = mmil_parms2args(parms,tags);
M_T1_to_T2_itr0= mmil_reg(fname_atl_T2,parms.fname_T2,args{:},...
  'outdir',outdir,...
  'fname_maskA', fname_mask_combine,...  
  'fname_regmat',fname_atlT2T1toT2_regmat,...
  'fname_regtxt',fname_atlT2T1toT2_regtxt,...
  'fname_regout',fname_atlT2T1_T2);
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% register T2 to T1 with jpdf: Iteration 1

outdir = [parms.outdir '/mireg01'];
fname_T2T1itr1_regmat = [outdir '/M_T1_to_T2_itr1.mat'];
fname_T2T1itr1_regtxt = [outdir '/M_T1_to_T2_itr1.txt'];
fname_T2_T1_itr1 = [outdir '/' tstem_T2 '_T1_itr1.mgz'];
parms.options = '-jpr -jpbrrMultScale';
tags = {'sincflag','interpm','logfile','binfile','paramfile','options','cleanup_flag'};
args = mmil_parms2args(parms,tags);
M_T1_to_T2_itr1 = mmil_reg(parms.fname_T1,fname_atlT2T1_T2,args{:},...
  'outdir',outdir,'rigid_flag',1,...
  'fname_maskA',fname_mask_combine,...
  'fname_regmat',fname_T2T1itr1_regmat ,...
  'fname_regtxt',fname_T2T1itr1_regtxt,...
  'fname_regout',fname_T2_T1_itr1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Apply transform to T2

M_T2itr1_to_T2 = M_T1_to_T2_itr0 * M_T1_to_T2_itr1;
[vol2,mrparms2,volsz2]= ctx_load_mgh(parms.fname_T2);
[vol1,mrparms1,volsz1]= ctx_load_mgh(parms.fname_T1);
vol2r= vol_resample_pad(vol2,vol1,M_T2itr1_to_T2,2,1);
fname_T2_T2 = [outdir '/' tstem_T2 '_T2_itr1.mgz'];
ctx_save_mgh(vol2r,fname_T2_T2,mrparms1);
clear vol1 vol2 vol2r;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% register T2 to T1 with jpdf: Iteration 2

outdir = [parms.outdir '/mireg02'];
fname_T2T1itr2_regmat = [outdir '/M_T1_to_T2_itr2.mat'];
fname_T2T1itr2_regtxt = [outdir '/M_T1_to_T2_itr2.txt'];
fname_T2_T1_itr2 = [outdir '/' tstem_T2 '_T1_itr2.mgz'];
parms.options = '-jpr -jpbrrMultScale';
tags = {'sincflag','interpm','logfile','binfile','paramfile','options','cleanup_flag'};
args = mmil_parms2args(parms,tags);
M_T1_to_T2_itr2 = mmil_reg(parms.fname_T1,fname_T2_T2,args{:},...
  'outdir',outdir,'rigid_flag',1,...
  'fname_maskA', fname_mask_combine,...
  'fname_regmat',fname_T2T1itr2_regmat,...
  'fname_regtxt',fname_T2T1itr2_regtxt,...
  'fname_regout',fname_T2_T1_itr2 );

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% calculate transformation between original volumes
M_T1_to_T2 = M_T2itr1_to_T2 * M_T1_to_T2_itr2;



